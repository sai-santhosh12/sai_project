./build.sh boot_sbl bmw_wave_high
./build_${TARGET_PLATFORM}.sh

[0;1;31mWarning:[[0m The unit file, source configuration file or drop-ins of in
it_sys_mss.service changed on disk. Run 'systemctl daemon-reload' to reload unit
s.
[[0;1;31m*[[0m init_sys_mss.service - Modem Init Service
     Loaded: loaded (/sbin/init_mss; disabled; vendor preset: disabled)
    Drop-In: /lib/systemd/system/init_sys_mss.service.d
             `-init_sys_mss.conf
     Active: [[0;1;31mfailed[[0m (Result: exit-code) since Thu 1970-01-01 00:00:
25 UTC; 3min 16s ago
    Process: 457 ExecStart=/sbin/init_mss [[0;1;31m(code=exited, status=1/FAILUR
E)[[0m
    Process: 458 ExecStartPost=/bin/sleep 6.5 (code=exited, status=0/SUCCESS)
   Main PID: 457 (code=exited, status=1/FAILURE)


uefi.elf
/home/worker/bmw_wav/boot_images/QcomPkg/SDX55Pkg/Bin/SDX55/LE/RELEASE/uefi.elf
/home/worker/bmw_wav_backup/boot_images_sbl/build/ms/bin/sdx55/nand

ls -al /home/worker/bmw_wav/boot_images_sbl/build/ms/bin/sdx55/nand/original/sbl1_nopreamble.mbn
-rw-r--r-- 1 worker worker 538300 May  9 12:51 /home/worker/bmw_wav/boot_images_sbl/build/ms/bin/sdx55/nand/original/sbl1_nopreamble.mbn

"${ARG1}" = "apps" -o "${ARG1}" = "apps-perf" -o "${ARG1}" = "boot_sbl" -o "${ARG1}" = "boot_uefi" -o "${ARG1}" = "aop" -o "${ARG1}" = "modem" -o "${ARG1}" = "tz" -o "${ARG1}" = "common" -o "${ARG1}" = "all" -o "${ARG1}" = "nhlos_all" -o "${ARG1}" = "apps_proc" -o "${ARG1}" = "apps_proc-perf" -o "${ARG1}" = "all-perf" -o "${ARG1}" = "sign" ]


git clone "ssh://aravind.b@vgit.lge.com:29420/nad/qct/sa515m/modem_proc" -b sa515m_le23_migration_wave_high_250317

git clone "ssh://anand.bommisetti@vgit.lge.com:29420/nad/qct/sa515m/boot_images_sbl"

git clone "ssh://anand.bommisetti@vgit.lge.com:29420/nad/qct/sa515m/boot_images"

git diff --binary --no-index /home/worker/qct_2.2/boot_images_sbl /home/worker/qct_2.2.1/sa515m-le-2-2-1_amss_standard_oem/SA515M_boot/boot_images > migration_sbl.txt

git diff --binary --no-index /home/worker/qct_2.2/boot_images /home/worker/qct_2.2.1/sa515m-le-2-2-1_amss_standard_oem/SA515M_uefi/boot_images > uefi.txt


mv /home/worker/qct_2.2.1/sa515m-le-2-2-1_amss_standard_oem/SA515M_boot/boot_images ~
mv /home/worker/qct_2.2/boot_images_sbl ~

git diff --binary --no-index /home/worker/boot_images_sbl /home/worker/boot_images >migration_sbl_path_change.txt

mv /home/worker/qct_2.2.1/sa515m-le-2-2-1_amss_standard_oem/boot_images_sbl /home/worker/qct_2.2

mv /home/worker/boot_images /home/worker/qct_2.2.1/sa515m-le-2-2-1_amss_standard_oem

D:\qct_2.2.1\boot_images_sbl\core\wiredconnectivity\qusb\src\al\qusb_al_bulk.c --> collect ramdump

cp -r /home/worker/bmw_wav /home/worker/bmw_wav
git patch >migration_sbl_changes.txt

repo init -u https://git.codelinaro.org/clo/private/private-le-au/le/manifest.git -b refs/tags/AU_LINUX_EMBEDDED_LE.UM.7.1.3.C1_TARGET_ALL.01.557.295 -m AU_LINUX_EMBEDDED_LE.UM.7.1.3.C1_TARGET_ALL.01.557.295.xml --repo-url=https://git.codelinaro.org/clo/tools/repo.git --repo-branch=qc-stable
repo sync -j8 --no-tags -c --no-clone-bundle --optimized-fetch


codes for codelinaro recovery
80ef31dddb81ce27
ed2ad21b82be486c
124c9bb4d93636eb
5cd2ded4dfb78b43
82d075c5306f21c4
0e0215bcf9ed3e64
c38158a0645ffb26
a8ba5785c4b31775
5b4da0e40317e9c6
ce11ff8bc045292f

~/qct_2.2.1/sa515m-le-2-2-1_amss_standard_oem/SA515M_apps/apps_proc


scp apps_proc_with_edk.zip nareshkumar.katepogu@10.221.31.89:/home/nareshkumar.katepogu/Anand
 
 
[WAVE][NAD][BSP][EV_ONLY] Add HW_REV_F and HW_REV_G string
 
[VLM]WAVE-78721
[HLF] T.1.13
[RS_ID] Modem
[DESC][0] Add HW_REV_F and HW_REV_G by string "F" and "G"
[ISSUETYPE] SV
[TEST][PASS] Booting and operation test is passed


git checkout wave_v013.142.000.high.oem_240621
repo init -u ssh://vgit.lge.com:29430/bmw/linux/manifest -b	wave_sop21_release -m nad-5g.xml -q --reference=/data001/vc.integrator/mirror/wave_sop21_release --repo-url=ssh://vgit.lge.com:29430/repo.git --no-clone-bundle
 
 
git checkout wave_v013.142.000.high.oem_240621

git push vgit_na HEAD:refs/for/wave_v013.142.000.high.oem_240621
 
 
 https://vgit.lge.com/na/c/nad/qct/sa515m/boot_images_sbl/+/1520396
 
 https://vgit.lge.com/na/c/common/nad/ntc/+/1520397
 
export SSTATE_LOCAL_MIRROR=$HOME/mirror/sstate-cache
export DL_DIR=~/mirror/downloads
export BB_NUMBER_THREADS=6
export PARALLEL_MAKE='-j 2'
export SCONS_OVERRIDE_NUM_JOBS=8



D:\qct_2.2.1\uefi\boot_images\QcomPkg\Drivers\SecRSADxe\Arm


SA515M	Main processor running Linux/Android/IVI apps (AP)
SDX55	5G modem (CP – communication processor) for telematics



worker@anand-bommisetti-bmwwave-high-src:~/bmw_wav_backup/aop_proc$ ls -al /pkg/qct/software/llvm/release/arm/4.0.11/bin
total 776060
drwxr-xr-x  2 worker worker     8192 Mar  2  2018 .
drwxr-xr-x 15 worker worker     4096 Jul  6  2018 ..
-rwxr-xr-x  1 worker worker   203437 Mar  2  2018 addr2line
-rwxr-xr-x  1 worker worker 34707197 Mar  2  2018 arm-link
-rwxr-xr-x  1 worker worker 21567086 Mar  2  2018 bugpoint
-rwxr-xr-x  1 worker worker 21325262 Mar  2  2018 c-index-test
-rwxr-xr-x  1 worker worker 62018637 Mar  2  2018 clang
-rwxr-xr-x  1 worker worker 62018637 Mar  2  2018 clang++
-rwxr-xr-x  1 worker worker 62018637 Mar  2  2018 clang-4.0
-rwxr-xr-x  1 worker worker 37830621 Mar  2  2018 clang-check
-rwxr-xr-x  1 worker worker 62018637 Mar  2  2018 clang-cl
-rwxr-xr-x  1 worker worker 62018637 Mar  2  2018 clang-cpp
-rwxr-xr-x  1 worker worker  1889696 Mar  2  2018 clang-format
-rwxr-xr-x  1 worker worker 21286489 Mar  2  2018 clang-import-test
-rwxr-xr-x  1 worker worker  2955862 Mar  2  2018 clang-offload-bundler
-rwxr-xr-x  1 worker worker    20626 Mar  2  2018 git-clang-format
-rwxr-xr-x  1 worker worker 34707197 Mar  2  2018 ld.qcld
-rwxr-xr-x  1 worker worker 24690647 Mar  2  2018 llc
-rwxr-xr-x  1 worker worker 19578874 Mar  2  2018 lli
-rwxr-xr-x  1 worker worker  5950012 Mar  2  2018 llvm-ar
-rwxr-xr-x  1 worker worker  2370021 Mar  2  2018 llvm-as
-rwxr-xr-x  1 worker worker   266530 Mar  2  2018 llvm-bcanalyzer
-rwxr-xr-x  1 worker worker  2332372 Mar  2  2018 llvm-cat
-rwxr-xr-x  1 worker worker   146375 Mar  2  2018 llvm-config
-rwxr-xr-x  1 worker worker  3072965 Mar  2  2018 llvm-cov
-rwxr-xr-x  1 worker worker 16074026 Mar  2  2018 llvm-c-test
-rwxr-xr-x  1 worker worker  2711626 Mar  2  2018 llvm-cxxdump
-rwxr-xr-x  1 worker worker   377856 Mar  2  2018 llvm-cxxfilt
-rwxr-xr-x  1 worker worker  2137179 Mar  2  2018 llvm-diff
-rwxr-xr-x  1 worker worker  1753006 Mar  2  2018 llvm-dis
-rwxr-xr-x  1 worker worker 16829773 Mar  2  2018 llvm-dsymutil
-rwxr-xr-x  1 worker worker  2895834 Mar  2  2018 llvm-dwarfdump
-rwxr-xr-x  1 worker worker 16390635 Mar  2  2018 llvm-dwp
-rwxr-xr-x  1 worker worker  3332013 Mar  2  2018 llvm-extract
-rwxr-xr-x  1 worker worker  5950012 Mar  2  2018 llvm-lib
-rwxr-xr-x  1 worker worker  3309700 Mar  2  2018 llvm-link
-rwxr-xr-x  1 worker worker 28396675 Mar  2  2018 llvm-lto
-rwxr-xr-x  1 worker worker 25114009 Mar  2  2018 llvm-lto2
-rwxr-xr-x  1 worker worker  4614592 Mar  2  2018 llvm-mc
-rwxr-xr-x  1 worker worker   225759 Mar  2  2018 llvm-mcmarkup
-rwxr-xr-x  1 worker worker  1926494 Mar  2  2018 llvm-modextract
-rwxr-xr-x  1 worker worker  6138214 Mar  2  2018 llvm-nm
-rwxr-xr-x  1 worker worker  6679708 Mar  2  2018 llvm-objdump
-rwxr-xr-x  1 worker worker   459097 Mar  2  2018 llvm-opt-report
-rwxr-xr-x  1 worker worker  1371439 Mar  2  2018 llvm-pdbdump
-rwxr-xr-x  1 worker worker   607321 Mar  2  2018 llvm-profdata
-rwxr-xr-x  1 worker worker  5950012 Mar  2  2018 llvm-ranlib
-rwxr-xr-x  1 worker worker   221964 Mar  2  2018 llvm-readelf
-rwxr-xr-x  1 worker worker  4123317 Mar  2  2018 llvm-readobj
-rwxr-xr-x  1 worker worker  4265609 Mar  2  2018 llvm-rtdyld
-rwxr-xr-x  1 worker worker  2730906 Mar  2  2018 llvm-size
-rwxr-xr-x  1 worker worker  2747192 Mar  2  2018 llvm-split
-rwxr-xr-x  1 worker worker  3226463 Mar  2  2018 llvm-stress
-rwxr-xr-x  1 worker worker   219881 Mar  2  2018 llvm-strings
-rwxr-xr-x  1 worker worker  3130650 Mar  2  2018 llvm-symbolizer
-rwxr-xr-x  1 worker worker  2208054 Mar  2  2018 llvm-tblgen
-rwxr-xr-x  1 worker worker  3461304 Mar  2  2018 llvm-xray
-rwxr-xr-x  1 worker worker   102381 Mar  2  2018 lto-as
-rwxr-xr-x  1 worker worker 16744786 Mar  2  2018 lto-test
-rwxr-xr-x  1 worker worker  3258702 Mar  2  2018 obj2yaml
-rwxr-xr-x  1 worker worker 33834707 Mar  2  2018 opt
-rwxr-xr-x  1 worker worker    26978 Mar  2  2018 post-process
-rwxr-xr-x  1 worker worker  6110643 Mar  2  2018 sancov
-rwxr-xr-x  1 worker worker  3084765 Mar  2  2018 sanstats
-rwxr-xr-x  1 worker worker    53728 Mar  2  2018 scan-build
-rwxr-xr-x  1 worker worker     4504 Mar  2  2018 scan-view
-rwxr-xr-x  1 worker worker  2646304 Mar  2  2018 verify-uselistorder
-rwxr-xr-x  1 worker worker   725058 Mar  2  2018 yaml2obj



worker@anand-bommisetti-bmwwave-high-src:~/bmw_wav_backup/aop_proc$ ls -al /pkg/qct/software/llvm/release/arm/4.0.12/bin
total 776060
drwxr-xr-x  2 worker worker     8192 Jan  2  2020 .
drwxr-xr-x 15 worker worker     4096 Jan  2  2020 ..
-rwxr-xr-x  1 worker worker   203437 Jan  2  2020 addr2line
-rwxr-xr-x  1 worker worker 34707197 Jan  2  2020 arm-link
-rwxr-xr-x  1 worker worker 21567086 Jan  2  2020 bugpoint
-rwxr-xr-x  1 worker worker 21325262 Jan  2  2020 c-index-test
-rwxr-xr-x  1 worker worker 62018637 Jan  2  2020 clang
-rwxr-xr-x  1 worker worker 62018637 Jan  2  2020 clang++
-rwxr-xr-x  1 worker worker 62018637 Jan  2  2020 clang-4.0
-rwxr-xr-x  1 worker worker 37830621 Jan  2  2020 clang-check
-rwxr-xr-x  1 worker worker 62018637 Jan  2  2020 clang-cl
-rwxr-xr-x  1 worker worker 62018637 Jan  2  2020 clang-cpp
-rwxr-xr-x  1 worker worker  1889696 Jan  2  2020 clang-format
-rwxr-xr-x  1 worker worker 21286489 Jan  2  2020 clang-import-test
-rwxr-xr-x  1 worker worker  2955862 Jan  2  2020 clang-offload-bundler
-rwxr-xr-x  1 worker worker    20626 Jan  2  2020 git-clang-format
-rwxr-xr-x  1 worker worker 34707197 Jan  2  2020 ld.qcld
-rwxr-xr-x  1 worker worker 24690647 Jan  2  2020 llc
-rwxr-xr-x  1 worker worker 19578874 Jan  2  2020 lli
-rwxr-xr-x  1 worker worker  5950012 Jan  2  2020 llvm-ar
-rwxr-xr-x  1 worker worker  2370021 Jan  2  2020 llvm-as
-rwxr-xr-x  1 worker worker   266530 Jan  2  2020 llvm-bcanalyzer
-rwxr-xr-x  1 worker worker  2332372 Jan  2  2020 llvm-cat
-rwxr-xr-x  1 worker worker   146375 Jan  2  2020 llvm-config
-rwxr-xr-x  1 worker worker  3072965 Jan  2  2020 llvm-cov
-rwxr-xr-x  1 worker worker 16074026 Jan  2  2020 llvm-c-test
-rwxr-xr-x  1 worker worker  2711626 Jan  2  2020 llvm-cxxdump
-rwxr-xr-x  1 worker worker   377856 Jan  2  2020 llvm-cxxfilt
-rwxr-xr-x  1 worker worker  2137179 Jan  2  2020 llvm-diff
-rwxr-xr-x  1 worker worker  1753006 Jan  2  2020 llvm-dis
-rwxr-xr-x  1 worker worker 16829773 Jan  2  2020 llvm-dsymutil
-rwxr-xr-x  1 worker worker  2895834 Jan  2  2020 llvm-dwarfdump
-rwxr-xr-x  1 worker worker 16390635 Jan  2  2020 llvm-dwp
-rwxr-xr-x  1 worker worker  3332013 Jan  2  2020 llvm-extract
-rwxr-xr-x  1 worker worker  5950012 Jan  2  2020 llvm-lib
-rwxr-xr-x  1 worker worker  3309700 Jan  2  2020 llvm-link
-rwxr-xr-x  1 worker worker 28396675 Jan  2  2020 llvm-lto
-rwxr-xr-x  1 worker worker 25114009 Jan  2  2020 llvm-lto2
-rwxr-xr-x  1 worker worker  4614592 Jan  2  2020 llvm-mc
-rwxr-xr-x  1 worker worker   225759 Jan  2  2020 llvm-mcmarkup
-rwxr-xr-x  1 worker worker  1926494 Jan  2  2020 llvm-modextract
-rwxr-xr-x  1 worker worker  6138214 Jan  2  2020 llvm-nm
-rwxr-xr-x  1 worker worker  6679708 Jan  2  2020 llvm-objdump
-rwxr-xr-x  1 worker worker   459097 Jan  2  2020 llvm-opt-report
-rwxr-xr-x  1 worker worker  1371439 Jan  2  2020 llvm-pdbdump
-rwxr-xr-x  1 worker worker   607321 Jan  2  2020 llvm-profdata
-rwxr-xr-x  1 worker worker  5950012 Jan  2  2020 llvm-ranlib
-rwxr-xr-x  1 worker worker   221964 Jan  2  2020 llvm-readelf
-rwxr-xr-x  1 worker worker  4123317 Jan  2  2020 llvm-readobj
-rwxr-xr-x  1 worker worker  4265609 Jan  2  2020 llvm-rtdyld
-rwxr-xr-x  1 worker worker  2730906 Jan  2  2020 llvm-size
-rwxr-xr-x  1 worker worker  2747192 Jan  2  2020 llvm-split
-rwxr-xr-x  1 worker worker  3226463 Jan  2  2020 llvm-stress
-rwxr-xr-x  1 worker worker   219881 Jan  2  2020 llvm-strings
-rwxr-xr-x  1 worker worker  3130650 Jan  2  2020 llvm-symbolizer
-rwxr-xr-x  1 worker worker  2208054 Jan  2  2020 llvm-tblgen
-rwxr-xr-x  1 worker worker  3461304 Jan  2  2020 llvm-xray
-rwxr-xr-x  1 worker worker   102381 Jan  2  2020 lto-as
-rwxr-xr-x  1 worker worker 16744786 Jan  2  2020 lto-test
-rwxr-xr-x  1 worker worker  3258702 Jan  2  2020 obj2yaml
-rwxr-xr-x  1 worker worker 33834707 Jan  2  2020 opt
-rwxr-xr-x  1 worker worker    26978 Jan  2  2020 post-process
-rwxr-xr-x  1 worker worker  6110643 Jan  2  2020 sancov
-rwxr-xr-x  1 worker worker  3084765 Jan  2  2020 sanstats
-rwxr-xr-x  1 worker worker    53728 Jan  2  2020 scan-build
-rwxr-xr-x  1 worker worker     4504 Jan  2  2020 scan-view
-rwxr-xr-x  1 worker worker  2646304 Jan  2  2020 verify-uselistorder
-rwxr-xr-x  1 worker worker   725058 Jan  2  2020 yaml2obj

Each compiler and assembler that supports an EABI creates object code that is compatible with code generated by other such compilers and assemblers. This allows developers to link libraries generated by one compiler with object code generated by another.

sudo apt-add-repository "deb http://apt.llvm.org/trusty/ llvm-toolchain-trusty-4.0 main"
/home/worker/bmw_wav_backup/trustzone_images
export PATH=$PATH:/home/worker/bmw_wav/trustzone_images/tools/xmlpp

/pkg/qct/software/python/2.7/bin/python


The .i files are also called as "Pure C files". In preprocessing stage

Header files will be included.

Macros will be replaced.

Comments are removed.

Used for conditional compilation. If you look at the .i file you can see these things.

/home/worker/python_fake/2.7/bin/python --version

export PATH=/home/worker/python_fake/2.7/bin:$PATH

ls -l /home/worker/python_fake/2.7/bin/python

hexagon sdk
This SDK provides developers with the necessary tools, libraries, and APIs to access and utilize the Hexagon DSP for application development


On NTFS volumes, each file can have multiple hard links, so a single file can appear in many directories 


MPC8315E-RDB Reference Platform ---> nas storage hardware and software by nxp




     +---------------------+
     | Power-On / Ignition |
     +---------------------+
                |
                v
+------------------------------------+
| 1. Power Management IC (PMIC) Init |
+------------------------------------+
| - Supplies power rails to SA515M   |
| - Clock/reset signals enabled      |
+------------------------------------+
                |
                v
+-----------------------------+
| 2. Primary Bootloader (PBL) |
+-----------------------------+
| - ROM code inside SoC       |
| - Initializes minimal HW    |
| - Loads SBL from eMMC/UFS   |
+-----------------------------+
                |
                v
+----------------------------+
| 3. Secondary Bootloader    |
|    (SBL or U-Boot)         |
+----------------------------+
| - Initializes DDR, UART    |
| - Sets up clocks, watchdog |
| - Initializes storage, etc.|
| - Verifies signed images   |
+----------------------------+
                |
                v
+----------------------------+
| 4. TrustZone/AVB (Secure)  |
+----------------------------+
| - Security verification    |
| - Secure monitor start     |
+----------------------------+
                |
                v
+----------------------------+
| 5. Kernel Boot (Linux/QNX) |
+----------------------------+
| - Loads kernel + DTB       |
| - Mounts root filesystem   |
| - Starts init system       |
+----------------------------+
                |
                v
+-------------------------------------+
| 6. Init System (Systemd/init.rc)    |
+-------------------------------------+
| - Starts essential services         |
| - Brings up network, logging        |
| - Launches TCU applications         |
+-------------------------------------+
                |
                v
+--------------------------------------+
| 7. Peripheral Init (NAD, GPS, SPI)   |
+--------------------------------------+
| - PCIe/USB communication to SDX55    |
| - SysInfoMgr detects NAD + HWEL      |
| - Antenna, eCall, GNSS powered up    |
+--------------------------------------+
                |
                v
+------------------------------+
| 8. Vehicle-Specific Services |
+------------------------------+
| - BTSR, IMS, V2X, etc.       |
| - HSM Init (if present)      |
| - Remote/OTA services        |
+------------------------------+

mount | grep '\--bind'
cat /proc/mounts | grep '\--bind'



/systemrw/sensorhal $ cat /proc/mounts
ubi0:rootfs / ubifs ro,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=0 0 0
devtmpfs /dev devtmpfs rw,seclabel,relatime,size=94844k,nr_inodes=23711,mode=755 0 0
sysfs /sys sysfs rw,seclabel,nosuid,nodev,noexec,relatime 0 0
proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0
tmpfs /dev/shm tmpfs rw,seclabel,nosuid,nodev 0 0
selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0
devpts /dev/pts devpts rw,seclabel,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 0 0
tmpfs /run tmpfs rw,seclabel,nosuid,nodev,mode=755 0 0
tmpfs /sys/fs/cgroup tmpfs ro,seclabel,nosuid,nodev,noexec,mode=755 0 0
cgroup2 /sys/fs/cgroup/unified cgroup2 rw,seclabel,nosuid,nodev,noexec,relatime,nsdelegate 0 0
cgroup /sys/fs/cgroup/systemd cgroup rw,seclabel,nosuid,nodev,noexec,relatime,xattr,name=systemd 0 0
none /sys/fs/bpf bpf rw,nosuid,nodev,noexec,relatime,mode=700 0 0
cgroup /sys/fs/cgroup/cpu,cpuacct cgroup rw,seclabel,nosuid,nodev,noexec,relatime,cpu,cpuacct 0 0
cgroup /sys/fs/cgroup/debug cgroup rw,seclabel,nosuid,nodev,noexec,relatime,debug 0 0
cgroup /sys/fs/cgroup/freezer cgroup rw,seclabel,nosuid,nodev,noexec,relatime,freezer 0 0
tmpfs /etc/machine-id tmpfs ro,seclabel,mode=755 0 0
ubi0:systemrw /systemrw ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
tmpfs /var/volatile tmpfs rw,rootcontext=system_u:object_r:var_t:s0,seclabel,relatime 0 0
/dev/ubi1_0 /firmware ubifs rw,context=system_u:object_r:firmware_t:s0,relatime,bulk_read,assert=read-only,ubi=1,vol=0 0 0
ubi0:persist /persist ubifs rw,rootcontext=system_u:object_r:persist_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=4 0 0
configfs /sys/kernel/config configfs rw,nosuid,nodev,noexec,relatime 0 0
debugfs /sys/kernel/debug debugfs rw,seclabel,nosuid,nodev,noexec,relatime 0 0
ubi0:systemrw /etc/data/mobileap_cfg.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:usrfs /data ubifs rw,rootcontext=system_u:object_r:data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=1 0 0
ubi0:systemrw /etc/data/netmgr_config.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/ipa_config.txt ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/mobileap_firewall.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/ipa/IPACM_cfg.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/wlan_cfg.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/l2tp_cfg.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/dhcp_hosts ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/usb/boot_hsusb_comp ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/hosts ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/adb_devid ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/usb/softap_w_dun ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
adb /dev/usb-ffs/adb functionfs rw,relatime 0 0
diag /dev/ffs-diag functionfs rw,relatime 0 0
tmpfs /tmp tmpfs rw,seclabel,nosuid,nodev 0 0
ubi0:systemrw /etc/sensorhal/hal_config ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/usb/boot_hsic_comp ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/c2c/c2c_vehicle.json ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/iproute2/rt_tables ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/adpl/adpl_config ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/tel.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/ipa/factory_IPACM_cfg.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/c2c/car2cloud.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/dnsmasq.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/adpl/mhi_enable ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/dsi_config.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/c2c/dm.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/c2c/ota.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/factory_l2tp_cfg.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/c2c/ota_session.json ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/factory_mobileap_cfg.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/c2c/side_loaded.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/factory_mobileap_firewall.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/c2c/softsku.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/factory_wlan_cfg.xml ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/c2c/sota.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/hostapd-eth0.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/c2c/sota_session.json ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/hostapd-eth1.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/mbim_mode ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/mobileap_cfg.xsd ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/mux_mode ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/wpa_supplicant-eth0.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:systemrw /etc/data/wpa_supplicant-eth1.conf ubifs rw,rootcontext=system_u:object_r:system_data_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=3 0 0
ubi0:cachefs /cache ubifs rw,rootcontext=system_u:object_r:cache_t:s0,seclabel,relatime,bulk_read,assert=read-only,ubi=0,vol=2 0 0
tracefs /sys/kernel/debug/tracing tracefs rw,seclabel,nosuid,nodev,noexec,relatime 0 0


[WAVE][NAD][BSP][EV_ONLY] Improve booting speed about init_sys_mss.service

[VLM]WAVE-78721
[HLF] T.1.13
[RS_ID] Modem
[DESC][0] Add HW_REV_F and HW_REV_G by string "F" and "G"
[ISSUETYPE] SV
[TEST][PASS] Booting and operation test is passed

Change-Id: Idc7bffdeff49ad78b5283f58f114cd2c9042677c

1520396:

4041ed72d545c4498674db3c3da92fe7c912dc2c


repo init -u ssh://vgit.lge.com:29430/bmw/linux/manifest -b   wave_sop21_release -m nad-5g.xml -q --reference=/data001/vc.integrator/mirror/wave_sop21_release --repo-url=ssh://vgit.lge.com:29430/repo.git --no-clone-bundle
repo sync -qc -j4 --no-tags
repo start sa515m_le22_release  --all


[WAVE][NAD][BSP][EV_ONLY] Add HW_REV_F and HW_REV_G string
 
[VLM]WAVE-78721
[HLF] T.1.13
[RS_ID] Modem
[DESC][0] Add HW_REV_F and HW_REV_G by string "F" and "G"
[ISSUETYPE] SV
[TEST][PASS] Booting and operation test is passed



Dear BMW Team,

We have observed elevated CPU usage primarily due to modem logging (DLT_MODEM), which in turn is contributing to an increase in system temperature, eventually leading to thermal shutdown events.

However, please note that modem logging is typically disabled in real-world environments. Therefore, this elevated CPU load and resulting thermal impact are not expected in real world enviornment.

To validate this further, we will monitor the CPU load after disabling the logging.


805133 2025/05/14 18:36:56.394021 66300.3374 124 WAVA TMLM TMMC 3159 log info verbose 10 [ thermal-monitor ][ ThermalMonitorService.cpp : 2274 ][ chkCloseOverTempStatus ] chkCloseOverTemp [AP:0,NAD:1] : Side = 2 temp = 105
810386 2025/05/14 18:37:04.544604 66308.4888 196 WAVA HTMT HSvc 2937 log info verbose 20 [ health-monitor , 3078 ][ HealthMonitorService.cpp : 1548 ][ cpuMonitoring ] [Cpu : 87.8425 %] [Cpu0 : 86.1487 %] [Cpu1 : 89.6194 %]
811711 2025/05/14 18:37:06.400588 66310.3412 140 WAVA PWRH PWRH 2038 log info verbose 15 [ PowerModeHandler ][ PowerModeHandler.cpp : 3107 ][ notifyThermalStateChanged ]  state :  Over-temperature , reason :  Due to NAD , ThermalTimerStarted :  false
811712 2025/05/14 18:37:06.400590 66310.3413 244 WAVA TELX TELX 2078 log info verbose 8 [ [TelephonyManagerService][ThermalMitigationHandler.cpp:237][notifyThermalStateChanged] : 2078 : 23158 ] mThermalState : THERMAL_MODE_SHUTDOWNffd51


telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 18.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 19.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 20.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 21.
[  926.357916] systemd-tmpfiles[2100]: /etc/tmpfiles.d/platform.conf:38: Line references path below legacy directory /var/run/, updating /var/run/resolv.conf → /run/resolv.conf; please update the tmpfiles.d/ drop-in file accordingly.
systemd-tmpfiles-clean.service: Succeeded.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 22.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 23.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 24.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 25.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 26.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 27.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 28.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 29.
telux_audio_server.service: Succeeded.
telux_audio_server.service: Scheduled restart job, restart counter is at 30.


27535 2025/06/03 15:12:26.521000 32.3050 200 WAVA RIL RILD 1663 log info verbose 1 [qcrilNrd][lge_oemhook_ntc_bsp.cpp:1390][qcrilhook_lge_ntc_nad_alive_status](tid:1757) [LGE_RIL] qmi_transport_error[0], result[0], error[0x0]
29281 2025/06/03 15:12:26.586000 1071.9617 221 WAVA RIL RILD 1663 log info verbose 1 [qcrilNrd][lge_oemhook_ntc_bsp.cpp:331][qcrilhook_lge_ntc_antenna_adc_ind](tid:1780) main[487954], diversity[486916], ext_bua[22318], gnss[10510], gnss_pt_sense[0]
29282 2025/06/03 15:12:26.586000 1071.9618 222 WAVA RIL RILD 1663 log info verbose 1 [qcrilNrd][ril.cpp:2950][sendUnsolResponse](tid:1780) <--- UNSOL_OEM_HOOK_RAW (1028)
29283 2025/06/03 15:12:26.586000 1071.9620 247 WAVA TELX TELX 2080 log info verbose 8 [ [TelephonyManagerService][RIL_Marshal.cpp:833][operator()] : 2080 : 2183 ]  [ 0 ] [UNSOL] < RIL_UNSOL_OEM_HOOK_RAW



229769 2025/06/03 15:24:19.362000 1786.0877 163 WAVA RIL RILD 1663 log info verbose 1 [qcrilNrd][lge_oemhook_ntc_bsp.cpp:1390][qcrilhook_lge_ntc_nad_alive_status](tid:1757) [LGE_RIL] qmi_transport_error[0], result[0], error[0x0]
229770 2025/06/03 15:24:19.362000 1786.0877 164 WAVA RIL RILD 1663 log info verbose 1 [qcrilNrd][ril.cpp:2004][lge_send_oemhook_response](tid:1757) <--- OEM_HOOK_RAW (59) --- [token: 281472023928496, E_SUCCESS]
229771 2025/06/03 15:24:19.362000 1786.0880 72 WAVA TELX TELX 2080 log info verbose 8 [ [TelephonyManagerService][RIL_Marshal.cpp:3194][operator()] : 2080 : 2183 ]  [PhoneId:0]: < RIL_REQUEST_OEM_HOOK_RAW received with err:0
229772 2025/06/03 15:24:19.362000 1786.0883 73 WAVA TELX TELX 2080 log info verbose 8 [ [TelephonyManagerService][RIL_Marshal.cpp:3200][operator()] : 2080 : 2183 ] RAW Data = 514f454d484f4f4b08000900080000000000000000000000
229773 2025/06/03 15:24:19.362000 1786.0885 74 WAVA TELX TELX 2080 log info verbose 8 [ [TelephonyManagerService][RILNADMonitor.cpp:795][handleMessage] : 2080 : 2166 ] EVENT_NAD_ALIVE_STATUS_DONE


306081 2025/06/03 15:28:13.425000 2020.1504 198 WAVA TMLM TMMC 2945 log info verbose 10 [ thermal-monitor ][ ThermalMonitorService.cpp : 2274 ][ chkCloseOverTempStatus ] chkCloseOverTemp [AP:0,NAD:0] : Side = 2 temp = 41

export SCONS_OVERRIDE_NUM_JOBS=2
export DL_DIR=~/mirror/downloads
export BB_NUMBER_THREADS="6"
export PARALLEL_MAKE="-j 2"


we have synced this branch mdm9650_le26_migration_250521 and could see the latest commits in the branch and given the build but we are not generate the images.the images that are missing are partition.mbn,tz.mbn,NON-HLOS.ubi,cmlib.mbn,devcfg.mbn,boot.img,cachefs.ubi,sysfs.ubi,recovery.ubi etc. kindly let us know where we are wrong.


In the case of WAVE-HIGH, to generate RomCopy, we move the patch file under the /modem_proc/ folder and apply the patch using the command below:
patch -p1 < 0001-WAVE-HIGH-make-cefs.patch
After that, the NON-HLOS.ubi file should be generated through the build process,
and then the cefs.mbn file needs to be backed up using PCAT

/home/worker/bmw_wave_2.2.1/apps_proc/poky/meta-lge/recipes-products/images/qti-tele-image.bbappend:7:



12049 2025/06/18 14:04:35.815092 1807.3969 3 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@108): {"Name": "Core", "cpuName": "cpu0", "usage": 98%, "totalUser": 44476, "totalNice": 0, "totalSys": 43569, "totalIdle": 70187}
12051 2025/06/18 14:04:35.815283 1807.3972 4 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@109): {"Name": "Core", "cpuName": "cpu0", "totalIowait": 690, "totalIrq": 0, "totalSoftIrq": 15568, "totalSteal": 0}
12052 2025/06/18 14:04:35.815380 1807.3972 5 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@108): {"Name": "Core", "cpuName": "cpu1", "usage": 96%, "totalUser": 49428, "totalNice": 0, "totalSys": 46885, "totalIdle": 37}
12053 2025/06/18 14:04:35.815476 1807.3973 6 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@109): {"Name": "Core", "cpuName": "cpu1", "totalIowait": 6, "totalIrq": 0, "totalSoftIrq": 944, "totalSteal": 0}
12054 2025/06/18 14:04:35.815575 1807.3973 7 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@108): {"Name": "Core", "cpuName": "cpu2", "usage": 95%, "totalUser": 46244, "totalNice": 0, "totalSys": 43224, "totalIdle": 16}

13421 2025/06/18 14:04:36.004155 1808.3403 121 WAVA PMGR TEMP 641 log info verbose 1 PowerCyclesWucClient::getCurrentTemperature for temperatureSource <AP> temperatureValue <97 °C>

53095 2025/06/18 14:05:03.932359 1836.7481 51 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@108): {"Name": "Core", "cpuName": "cpu0", "usage": 51%, "totalUser": 45275, "totalNice": 0, "totalSys": 44385, "totalIdle": 71075}
53096 2025/06/18 14:05:03.932453 1836.7481 52 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@109): {"Name": "Core", "cpuName": "cpu0", "totalIowait": 698, "totalIrq": 0, "totalSoftIrq": 15923, "totalSteal": 0}
53098 2025/06/18 14:05:03.932646 1836.7483 53 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@108): {"Name": "Core", "cpuName": "cpu1", "usage": 52%, "totalUser": 50330, "totalNice": 0, "totalSys": 47801, "totalIdle": 1041}
53100 2025/06/18 14:05:03.932877 1836.7484 54 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@109): {"Name": "Core", "cpuName": "cpu1", "totalIowait": 32, "totalIrq": 0, "totalSoftIrq": 956, "totalSteal": 0}
53101 2025/06/18 14:05:03.932973 1836.7486 55 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@108): {"Name": "Core", "cpuName": "cpu2", "usage": 52%, "totalUser": 47182, "totalNice": 0, "totalSys": 44090, "totalIdle": 1015}
53102 2025/06/18 14:05:03.933068 1836.7486 56 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@109): {"Name": "Core", "cpuName": "cpu2", "totalIowait": 28, "totalIrq": 0, "totalSoftIrq": 940, "totalSteal": 0}

89014 2025/06/18 14:05:33.057070 1865.8737 151 WAVA PMGR TEMP 641 log info verbose 1 PowerCyclesWucClient::notifyTemperatureThreshold event temperatureSource <AP> temperatureValue <105 °C>

91115 2025/06/18 14:05:34.488944 1867.2656 99 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@108): {"Name": "Core", "cpuName": "cpu0", "usage": 71%, "totalUser": 46172, "totalNice": 0, "totalSys": 45118, "totalIdle": 72096}
91116 2025/06/18 14:05:34.489041 1867.2657 100 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@109): {"Name": "Core", "cpuName": "cpu0", "totalIowait": 706, "totalIrq": 0, "totalSoftIrq": 16245, "totalSteal": 0}
91117 2025/06/18 14:05:34.489144 1867.2657 101 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@108): {"Name": "Core", "cpuName": "cpu1", "usage": 69%, "totalUser": 51330, "totalNice": 0, "totalSys": 48636, "totalIdle": 2126}
91118 2025/06/18 14:05:34.489245 1867.2657 102 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@109): {"Name": "Core", "cpuName": "cpu1", "totalIowait": 57, "totalIrq": 0, "totalSoftIrq": 971, "totalSteal": 0}
91119 2025/06/18 14:05:34.489345 1867.2658 103 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@108): {"Name": "Core", "cpuName": "cpu2", "usage": 68%, "totalUser": 48172, "totalNice": 0, "totalSys": 44913, "totalIdle": 2105}
91120 2025/06/18 14:05:34.489446 1867.2658 104 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@109): {"Name": "Core", "cpuName": "cpu2", "totalIowait": 52, "totalIrq": 0, "totalSoftIrq": 958, "totalSteal": 0}



92485 2025/06/18 14:05:35.534839 1868.3408 161 WAVA PMGR TEMP 641 log info verbose 1 PowerCyclesWucClient::getCurrentTemperature for temperatureSource <AP> temperatureValue <105 °C>


150374 2025/06/18 14:06:33.893010 1926.7102 198 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@109): {"Name": "Core", "cpuName": "cpu1", "totalIowait": 94, "totalIrq": 0, "totalSoftIrq": 994, "totalSteal": 0}
150375 2025/06/18 14:06:33.893110 1926.7102 199 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@108): {"Name": "Core", "cpuName": "cpu2", "usage": 51%, "totalUser": 49893, "totalNice": 0, "totalSys": 46308, "totalIdle": 4693}
150376 2025/06/18 14:06:33.893204 1926.7102 200 WAVA SYS CPU 363 log debug verbose 1 (PathologyCollectorCPU.cpp: getLoad(...)@109): {"Name": "Core", "cpuName": "cpu2", "totalIowait": 88, "totalIrq": 0, "totalSoftIrq": 988, "totalSteal": 0}

//AP temperature was also high and it is raising
151825 2025/06/18 14:06:35.529665 1928.3420 189 WAVA PMGR TEMP 641 log info verbose 1 PowerCyclesWucClient::getCurrentTemperature for temperatureSource <AP> temperatureValue <109 °C>


//NAD temperature above 104
151849 2025/06/18 14:06:35.544435 1928.3622 219 WAVA PMSP heat 244 log info verbose 2 TemperatureMonitorStubImpl.cpp:388 Replying Temperature of OEM_NAD_TJ: 110°C, error number 1
151850 2025/06/18 14:06:35.545311 1928.3635 197 WAVA PMGR TEMP 641 log info verbose 1 PowerCyclesWucClient::getCurrentTemperature for temperatureSource <OEM_NAD_TJ> temperatureValue <110 °C>
151851 2025/06/18 14:06:35.548170 1928.3641 198 WAVA PMGR TEMP 641 log info verbose 1 ThermalMitigationSource::obtainThermalMitigationLevel source <OEM_NAD_TJ> temperature <110 °C>  ==> level <3>


195501 2025/06/18 14:07:35.972769 1988.3543 222 WAVA PMGR TEMP 641 log info verbose 1 ThermalMitigationSource::obtainThermalMitigationLevel source <AP> temperature <111 °C>  ==> level <4>


SAHARA PROTOCOL

Sahara protocol is target-driven.
✅ What does that mean?

Sahara is a Qualcomm boot protocol used during the very early stage of device boot (before the OS loads).
It runs in the boot ROM of the target device.
The target (device) controls the session and dictates what the host (PC) can do.
The host (e.g., QSaharaServer.exe) simply responds to requests from the target and sends the required files (like Firehose programmer).


✅ Sahara vs Firehose

Sahara: Used to download the programmer (e.g., prog_emmc_firehose_8909_ddr.mbn) into the device’s RAM.
Firehose: Once the programmer is loaded, the device switches to Firehose mode, which allows raw eMMC/NAND flashing commands.

The first command HELLO was send from
target device to the PC after the first power on sequence. If the first Hello command hasn't
been captured by PC tool, it will fail to load the device programmer. Subsequent calls for
QSaharaServer won't succeed either. So the power on sequence is very important for Sahara
protocol.
If the flash is empty, here is the suggestion to power on the device
Disconnect the battery and extern power supply
Disconnect the USB cable
Wait for 3~5 seconds
Reconnect the USB cable to the PC
Reconnect the battery / extern power supply if needed (the power supply from USB
cable may be enough on some devices)
Run QSaharaServer command to load the device programmer
Enable the verbose to get more detail information
// Logging level
enum {
LOG_ERROR = 0,
LOG_INFO = 1,
LOG_WARN = 2,
LOG_EVENT = 3,
LOG_STATUS = 4
} LOG_LEVEL;
eg. QSaharaServer.exe -v 1 -p \\.\COM5 -s 13:D:\images\8909\prog_emmc_firehose_8909_
ddr.mbn
Capture the port data with Bus Hound
It's very helpful to capture the USB port data with a third-party tool such as BUS Hound. To
parse the command and response, suggest to refer to the doc 80-N1008-1 SAHARA
PROTOCOL SPECIFICATION
Here is an example - The timing to open EDL COM port is mismatched with the timing to
receive the HELLO command (The HELLO command packet has been sent before COM port
was opened)
It seems the first HELLO command from device has already been captured by some unknown
process on Windows OS when using \\.\COMx format as the parameter
Port data captured by Bus Hound
15.1 48 IN 01 00 00 00 .... 27.1.0 2015-10-15 10:19:38.432 qcusbser





-------------------------------------------------------------------------------------------------------------------------------------------------


FOR REMOVING LOCATION_HAL_DEAMON SERVICE CHANGES MADE In

/home/worker/bmw_wave_2.2.1/apps_proc/poky/meta-qti-location/recipes/packagegroups/packagegroup-qti-location.bb
   location-hal-daemon \

/home/worker/bmw_wave_2.2.1/apps_proc/poky/meta-lge/conf/layer.conf


BBMASK +="/home/worker/bmw_wave_2.2.1/apps_proc/poky/meta-qti-location/recipes/location/location-hal-daemon_git.bb"

NAO debug = AP+CP will be active. Expected measure is ~ 0.35mA
NAO Mode = AP Sleep +CP idle , Expected measure is ~ 0.002mA

ramdump changes commit http://vgit.lge.com/na/c/nad/qct/mdm9650/apps_proc/kernel/msm-3.18/+/1530674 



sh-3.2# ps | grep mdm
sh-3.2# systemctl status modem_log
● modem_log.service - modem dlt logger configuration
   Loaded: loaded (/lib/systemd/system/modem_log.service; disabled; vendor preset: enabled)
   Active: active (running) since Thu 2025-07-03 07:39:00 UTC; 38s ago
  Process: 375 ExecStartPre=/bin/sh -c /usr/bin/modem_log.sh (code=exited, status=0/SUCCESS)
  Process: 358 ExecStartPre=/bin/sh -c /usr/bin/create_rdmp_disk.sh (code=exited, status=0/SUCCESS)
  Process: 356 ExecStartPre=/bin/sh -c echo 2 > /proc/irq/14/smp_affinity (code=exited, status=0/SUCCESS)
 Main PID: 2794 (mdmDltLogger)
   CGroup: /system.slice/modem_log.service
           └─2794 /usr/bin/mdmDltLogger -p /var/log/ramdump -n 0
sh-3.2# ps
  PID TTY          TIME CMD
 8087 pts/0    00:00:00 ps
11718 pts/0    00:00:00 sh
sh-3.2# ps -al
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 R     0 16023 11718  0  80   0 -  1920 -      pts/0    00:00:00 ps
sh-3.2# ps -a
  PID TTY          TIME CMD
16387 pts/0    00:00:00 ps
sh-3.2# cd /proc/2794
sh-3.2# ls
attr             fd               net              setgroups
autogroup        fdinfo           ns               smaps
auxv             gid_map          numa_maps        smaps_rollup
cgroup           io               oom_adj          stack
clear_refs       limits           oom_score        stat
cmdline          loginuid         oom_score_adj    statm
comm             map_files        pagemap          status
coredump_filter  maps             personality      syscall
cpuset           mem              projid_map       task
cwd              mountinfo        root             timerslack_ns
environ          mounts           schedstat        uid_map
exe              mountstats       sessionid        wchan
sh-3.2# cat cmdline
/usr/bin/mdmDltLogger-p/var/log/ramdump-n0sh-3.2# cd var
sh: cd: var: No such file or directory
sh-3.2# ls
attr             fd               net              setgroups
autogroup        fdinfo           ns               smaps
auxv             gid_map          numa_maps        smaps_rollup
cgroup           io               oom_adj          stack
clear_refs       limits           oom_score        stat
cmdline          loginuid         oom_score_adj    statm
comm             map_files        pagemap          status
coredump_filter  maps             personality      syscall
cpuset           mem              projid_map       task
cwd              mountinfo        root             timerslack_ns
environ          mounts           schedstat        uid_map
exe              mountstats       sessionid        wchan
sh-3.2# cd /var/log/
sh-3.2# ls
Tigrisd            crash_reason       lost+found         tigris_01
audit              dlt                networkDevice.txt  tigris_02
btmp               fsck_result        panic              wtmp
chrony             lastlog            ramdump
core               log_fsck_result    tigris_00
sh-3.2# cd dlt/
sh-3.2# ls
attach.txt                       dlt_offlinetrace.0000000004.dlt
count.txt                        dlt_offlinetrace.0000000005.dlt
dlt-dtc                          dlt_offlinetrace.0000000006.dlt
dlt_offlinetrace.0000000001.dlt  dlt_offlinetrace.0000000007.dlt
dlt_offlinetrace.0000000002.dlt  dlt_offlinetrace.0000000008.dlt
dlt_offlinetrace.0000000003.dlt  filetransfer
sh-3.2# cd ../
sh-3.2# ls
Tigrisd            crash_reason       lost+found         tigris_01
audit              dlt                networkDevice.txt  tigris_02
btmp               fsck_result        panic              wtmp
chrony             lastlog            ramdump
core               log_fsck_result    tigris_00
sh-3.2# cd ../
sh-3.2# ls
backups           irtm              lock              spool
cache             kvsdatabase.json  log               tmp
db                lib               optee             volatile
encrypted         local             run
sh-3.2# lsusb -v

Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               3.00
  bDeviceClass            9 Hub
  bDeviceSubClass         0
  bDeviceProtocol         3
  bMaxPacketSize0         9
  idVendor           0x1d6b Linux Foundation
  idProduct          0x0003 3.0 root hub
  bcdDevice            4.14
  iManufacturer           3 Linux 4.14.98 xhci-hcd
  iProduct                2 xHCI Host Controller
  iSerial                 1 xhci-cdns3
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength           31
    bNumInterfaces          1
    bConfigurationValue     1
    iConfiguration          0
    bmAttributes         0xe0
      Self Powered
      Remote Wakeup
    MaxPower                0mA
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass         9 Hub
      bInterfaceSubClass      0
      bInterfaceProtocol      0 Full speed (or root) hub
      iInterface              0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0004  1x 4 bytes
        bInterval              12
        bMaxBurst               0
Hub Descriptor:
  bLength              12
  bDescriptorType      42
  nNbrPorts             1
  wHubCharacteristic 0x0009
    Per-port power switching
    Per-port overcurrent protection
  bPwrOn2PwrGood       10 * 2 milli seconds
  bHubContrCurrent      0 milli Ampere
  bHubDecLat          0.0 micro seconds
  wHubDelay             0 nano seconds
  DeviceRemovable    0x00
 Hub Port Status:
   Port 1: 0000.02a0 5Gbps power Rx.Detect
Binary Object Store Descriptor:
  bLength                 5
  bDescriptorType        15
  wTotalLength           15
  bNumDeviceCaps          1
  SuperSpeed USB Device Capability:
    bLength                10
    bDescriptorType        16
    bDevCapabilityType      3
    bmAttributes         0x02
      Latency Tolerance Messages (LTM) Supported
    wSpeedsSupported   0x0008
      Device can operate at SuperSpeed (5Gbps)
    bFunctionalitySupport   3
      Lowest fully-functional device speed is SuperSpeed (5Gbps)
    bU1DevExitLat           0 micro seconds
    bU2DevExitLat           0 micro seconds
can't get debug descriptor: Resource temporarily unavailable
Device Status:     0x0001
  Self Powered

Bus 001 Device 002: ID 05c6:901f Qualcomm, Inc.
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.10
  bDeviceClass            0
  bDeviceSubClass         0
  bDeviceProtocol         0
  bMaxPacketSize0        64
  idVendor           0x05c6 Qualcomm, Inc.
  idProduct          0x901f
  bcdDevice            4.14
  iManufacturer           1 QCOM
  iProduct                2 SDXPRAIRIE-ADP _SN:B829B5CF
  iSerial                 3 b829b5cf
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength          104
    bNumInterfaces          3
    bConfigurationValue     1
    iConfiguration          4 DIAG_ADB_DUN
    bmAttributes         0xa0
      (Bus Powered)
      Remote Wakeup
    MaxPower              500mA
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           2
      bInterfaceClass       255 Vendor Specific Class
      bInterfaceSubClass    255 Vendor Specific Subclass
      bInterfaceProtocol     48
      iInterface              0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0200  1x 512 bytes
        bInterval               0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x01  EP 1 OUT
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0200  1x 512 bytes
        bInterval               0
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        1
      bAlternateSetting       0
      bNumEndpoints           2
      bInterfaceClass       255 Vendor Specific Class
      bInterfaceSubClass     66
      bInterfaceProtocol      1
      iInterface              5 ADB Interface
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x02  EP 2 OUT
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0200  1x 512 bytes
        bInterval               0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x82  EP 2 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0200  1x 512 bytes
        bInterval               0
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        2
      bAlternateSetting       0
      bNumEndpoints           3
      bInterfaceClass       255 Vendor Specific Class
      bInterfaceSubClass    255 Vendor Specific Subclass
      bInterfaceProtocol     64
      iInterface              0
      ** UNRECOGNIZED:  05 24 00 10 01
      ** UNRECOGNIZED:  05 24 01 00 00
      ** UNRECOGNIZED:  04 24 02 02
      ** UNRECOGNIZED:  05 24 06 00 00
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x84  EP 4 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x000a  1x 10 bytes
        bInterval               9
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x83  EP 3 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0200  1x 512 bytes
        bInterval               0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x03  EP 3 OUT
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0200  1x 512 bytes
        bInterval               0
Binary Object Store Descriptor:
  bLength                 5
  bDescriptorType        15
  wTotalLength           42
  bNumDeviceCaps          3
  USB 2.0 Extension Device Capability:
    bLength                 7
    bDescriptorType        16
    bDevCapabilityType      2
    bmAttributes   0x00000006
      BESL Link Power Management (LPM) Supported
  SuperSpeed USB Device Capability:
    bLength                10
    bDescriptorType        16
    bDevCapabilityType      3
    bmAttributes         0x00
    wSpeedsSupported   0x000f
      Device can operate at Low Speed (1Mbps)
      Device can operate at Full Speed (12Mbps)
      Device can operate at High Speed (480Mbps)
      Device can operate at SuperSpeed (5Gbps)
    bFunctionalitySupport   1
      Lowest fully-functional device speed is Full Speed (12Mbps)
    bU1DevExitLat           1 micro seconds
    bU2DevExitLat         500 micro seconds
  SuperSpeedPlus USB Device Capability:
    bLength                20
    bDescriptorType        16
    bDevCapabilityType     10
    bmAttributes         0x00000001
      Sublink Speed Attribute count 1
      Sublink Speed ID count 0
    wFunctionalitySupport   0x1100
    bmSublinkSpeedAttr[0]   0x000a4030
      Speed Attribute ID: 0 10Gb/s Symmetric RX SuperSpeedPlus
    bmSublinkSpeedAttr[1]   0x000a40b0
      Speed Attribute ID: 0 10Gb/s Symmetric TX SuperSpeedPlus
can't get debug descriptor: Resource temporarily unavailable
Device Status:     0x0000
  (Bus Powered)

Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass            9 Hub
  bDeviceSubClass         0
  bDeviceProtocol         1 Single TT
  bMaxPacketSize0        64
  idVendor           0x1d6b Linux Foundation
  idProduct          0x0002 2.0 root hub
  bcdDevice            4.14
  iManufacturer           3 Linux 4.14.98 xhci-hcd
  iProduct                2 xHCI Host Controller
  iSerial                 1 xhci-cdns3
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength           25
    bNumInterfaces          1
    bConfigurationValue     1
    iConfiguration          0
    bmAttributes         0xe0
      Self Powered
      Remote Wakeup
    MaxPower                0mA
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass         9 Hub
      bInterfaceSubClass      0
      bInterfaceProtocol      0 Full speed (or root) hub
      iInterface              0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0004  1x 4 bytes
        bInterval              12
Hub Descriptor:
  bLength               9
  bDescriptorType      41
  nNbrPorts             1
  wHubCharacteristic 0x0009
    Per-port power switching
    Per-port overcurrent protection
    TT think time 8 FS bits
  bPwrOn2PwrGood       10 * 2 milli seconds
  bHubContrCurrent      0 milli Ampere
  DeviceRemovable    0x00
  PortPwrCtrlMask    0xff
 Hub Port Status:
   Port 1: 0000.0503 highspeed power enable connect
can't get device qualifier: Resource temporarily unavailable
can't get debug descriptor: Resource temporarily unavailable
Device Status:     0x0001
  Self Powered



sh-3.2# cd debug/diag/status |grep HDLC
sh: cd: debug/diag/status: Not a directory
sh-3.2# cd debug/diag/
sh-3.2# cat status |grep HDLC
Apps Supports HDLC Encoding: 1
HDLC Disabled: 0
sh-3.2# cat status
CPU Tools ID: 0
Check Polling Response: 1
Polling Registered: 0
Uses Device Tree: 1
Apps Supports Separate CMDRSP: 1
Apps Supports HDLC Encoding: 1
Apps Supports Header Untagging: 1
Apps Supports Sockets: 1
Logging Mode: 0
RSP Buffer is Busy: 0
HDLC Disabled: 0
Time Sync Enabled: 0
MD session mode: 0
MD session mask: 0
Uses Time API: 0
Supports PD buffering: 1
p: MODEM Feature: 00 00 |fchbmpqstu|
p: LPASS Feature: 00 00 |fchbmpqstu|
p: WCNSS Feature: 00 00 |fchbmpqstu|
p: SENSORS Feature: 00 00 |fchbmpqstu|
p: WDSP Feature: 00 00 |fchbmpqstu|
p: CDSP Feature: 00 00 |fchbmpqstu|
USB Connected: 0
Real Time Mode: 0: 1
Real Time Mode: 1: 1
Real Time Mode: 2: 1
sh-3.2#



 /wave_sop21_release/a35/uboot-imx/cmd/bootm.c ------>a35 uses u-boot as a bootloader that will loads kernel


root@imx8qxpmek:~# qrtr-lookup
 Service Version Instance Node Port
 45 1 0 3 68 <unknown>
 29 1 0 3 55 Circuit switched videotelephony
service
 17 1 0 3 29 Specific absorption rate service
 49 1 2 3 16 IPA control service
 77 1 0 3 58 <unknown>
 12 1 0 3 45 Phonebook Management service
 15 1 0 3 6 Test service
 5 1 0 3 61 Wireless Messaging Service
 3 1 0 3 48 Network Access Service
 4097 N/A 1 3 22 DIAG service (MODEM:CMD)
 24 1 0 3 9 Thermal mitigation device service
 4 1 0 3 51 Quality Of Service service
 54 1 0 3 25 <unknown>
 78 1 0 3 67 <unknown>
 
 
 sh-3.2# cat sys/devices/platform/wave-control/board_rev
D3



sh-3.2# qrtr-lookup
  Service Version Instance Node  Port
       18       1        0    3    81 IMS settings service
       48       1        0    3    68 <unknown>
       10       2        0    3    55 Card Application Toolkit service (v2)
     5004     239      222    3    42 <unknown>
       78       1        0    3    71 <unknown>
       25       1        0    3    58 Service access proxy service
     1067       1        0    3    45 <unknown>
       84       1        0    3     6 <unknown>
        5       1        0    3    74 Wireless Messaging Service
        4       1        0    3    61 Quality Of Service service
      228       1        0    3     9 <unknown>
       45       1        0    3    77 <unknown>
       77       1        0    3    64 <unknown>
       36       1        0    3    25 Persistent device configuration service
       21       1        0    3    12 Modem embedded file system service
       33       1        0    3    80 IMS application service
        2       1        0    3    67 Device Management Service
        3       1        0    3    54 Network Access Service
       41       1        1    3    41 RF radiated performance enhancement service
       66       1      165    3     2 Service registry notification service
       71       1        0    3    83 <unknown>
       73       1        0    3    70 <unknown>
       11       1        0    3    57 User Identity Module service
        7       1        0    3    73 Authentication service
        1       1        0    3    60 Wireless Data Service
       15       1        0    3     8 Test service
        8       1        0    3    63 AT service
       12       1        0    3    50 Phonebook Management service
       23       1      100    3    24 Thermal sensors service
       51       1        2    3    11 CoreSight remote tracing service
       74       1        0    3    79 <unknown>
       42       1        0    3    66 Data system determination service
        9       2        0    3    53 Voice service
       34       1        0    3    40 Coexistence service
       43       2       34    3     1 Subsystem control service
       68       1        0    3    69 <unknown>
       47       1        0    3    56 <unknown>
     4097     N/A        1    3    17 DIAG service (MODEM:CMD)
       29       1        0    3    72 Circuit switched videotelephony service
      227       1        0    3    59 <unknown>
       76       1        0    3    46 <unknown>
     4097     N/A        3    3    20 DIAG service (MODEM:DCI_CMD)
       16       2        0    3    75 Location service (~ PDS v2)
       26       1        0    3    62 Wireless data administrative service
      704       3        1    3    49 <unknown>
       22       1       32    3    23 Time service
      229       1        0    3    10 <unknown>
       75       1        0    3    78 <unknown>
       50       1        0    3    52 <unknown>
       17       1        0    3    39 Specific absorption rate service
       49       1        2    3    26 IPA control service
       24       1      100    3    13 Thermal mitigation device service
       49       1        1    2 16384 IPA control service
     4097     N/A      514    2 16452 DIAG service (<unk>:DATA)
     5004       2        0    2 16614 <unknown>
     4097     N/A        4    2 16413 DIAG service (MODEM:DCI)
     4096       8        0    2 16400 <unknown>
     1061       1        0    2 16643 <unknown>
     1024       1        0    2 16468 <unknown>
     4097     N/A      576    2 16455 DIAG service (<unk>:CNTL)
     4097     N/A      386    2 16442 DIAG service (<unk>:DATA)
     1062       1        0    2 16685 <unknown>
     4096      11        0    2 16403 <unknown>
     4097     N/A      580    2 16458 DIAG service (<unk>:DCI)
     4097     N/A      448    2 16445 DIAG service (<unk>:CNTL)
     4097     N/A      258    2 16432 DIAG service (CDSP:DATA)
     4096       1        0    2 16393 <unknown>
     4097     N/A      452    2 16448 DIAG service (<unk>:DCI)
     4097     N/A      320    2 16435 DIAG service (WDSP:CNTL)
     4097     N/A      130    2 16422 DIAG service (WCNSS:DATA)
     4096       4        0    2 16396 <unknown>
     5004       1        0    2 16613 <unknown>
     4097     N/A      324    2 16438 DIAG service (WDSP:DCI)
     4097     N/A      192    2 16425 DIAG service (SENSORS:CNTL)
     4097     N/A        2    2 16412 DIAG service (MODEM:DATA)
     4096       7        0    2 16399 <unknown>
     4097     N/A      196    2 16428 DIAG service (SENSORS:DCI)
     4097     N/A       64    2 16415 DIAG service (LPASS:CNTL)
     4096      10        0    2 16402 <unknown>
     4097     N/A      578    2 16457 DIAG service (<unk>:DATA)
     5001       1        0    2 16606 <unknown>
     4097     N/A       68    2 16418 DIAG service (LPASS:DCI)
       53       1       16    2 16392 <unknown>
     4097     N/A      640    2 16460 DIAG service (<unk>:CNTL)
     4097     N/A      450    2 16447 DIAG service (<unk>:DATA)
     4096       3        0    2 16395 <unknown>
     4097     N/A      644    2 16463 DIAG service (<unk>:DCI)
     4097     N/A      512    2 16450 DIAG service (<unk>:CNTL)
     1059       1        0    2 16612 <unknown>
     4097     N/A      322    2 16437 DIAG service (WDSP:DATA)
     4096       6        0    2 16398 <unknown>
     1063       1        0    2 16654 <unknown>
     4097     N/A      516    2 16453 DIAG service (<unk>:DCI)
     4097     N/A      384    2 16440 DIAG service (<unk>:CNTL)
     4097     N/A      194    2 16427 DIAG service (SENSORS:DATA)
     4096       9        0    2 16401 <unknown>
     1072       1        0    2 16644 <unknown>
     4097     N/A      388    2 16443 DIAG service (<unk>:DCI)
       55       1        1    2 16605 <unknown>
     4097     N/A      256    2 16430 DIAG service (CDSP:CNTL)
     4097     N/A       66    2 16417 DIAG service (LPASS:DATA)
     4096      12        0    2 16404 <unknown>
     4097     N/A      260    2 16433 DIAG service (CDSP:DCI)
     4097     N/A      128    2 16420 DIAG service (WCNSS:CNTL)
     4096       2        0    2 16394 <unknown>
     4097     N/A      642    2 16462 DIAG service (<unk>:DATA)
     4097     N/A      132    2 16423 DIAG service (WCNSS:DCI)
     4097     N/A        0    2 16410 DIAG service (MODEM:CNTL)
     4096       5        0    2 16397 <unknown>
     4097     N/A       68    1 16413 DIAG service (LPASS:DCI)
     4097     N/A      132    1 16403 DIAG service (WCNSS:DCI)
     4097     N/A      322    1 16406 DIAG service (WDSP:DATA)
     4097     N/A      260    1 16409 DIAG service (CDSP:DCI)
     4097     N/A       66    1 16412 DIAG service (LPASS:DATA)
     4097     N/A      192    1 16415 DIAG service (SENSORS:CNTL)
     4097     N/A      130    1 16402 DIAG service (WCNSS:DATA)
     4097     N/A      196    1 16405 DIAG service (SENSORS:DCI)
     4097     N/A      258    1 16408 DIAG service (CDSP:DATA)
     4097     N/A      256    1 16411 DIAG service (CDSP:CNTL)
     4097     N/A      128    1 16414 DIAG service (WCNSS:CNTL)
     4097     N/A      320    1 16401 DIAG service (WDSP:CNTL)
     4097     N/A      194    1 16404 DIAG service (SENSORS:DATA)
     4097     N/A      324    1 16407 DIAG service (WDSP:DCI)
     4097     N/A       64    1 16410 DIAG service (LPASS:CNTL)
	 
	 
	 
	 
	 /proc/sys/kernel # cat printk_ratelimit
5
/proc/sys/kernel # cat printk_ratelimit_burst
10
	 
	 
	 
	 
	 
	 
repo init -u ssh://vgit.lge.com:29430/bmw/linux/manifest -b wave_sop21_release -m nad.xml -q --reference=/data001/vc.integrator/mirror/wave_sop21_release --repo-url=ssh://vgit.lge.com:29430/repo.git --no-clone-bundle
repo sync -j16
repo start wave_sop21_release --all



/ # cat /proc/meminfo
MemTotal:         124104 kB
MemFree:            9540 kB
MemAvailable:      70196 kB
Buffers:               0 kB
Cached:            59164 kB
SwapCached:            0 kB
Active:            45036 kB
Inactive:          28076 kB
Active(anon):      14008 kB
Inactive(anon):       60 kB
Active(file):      31028 kB
Inactive(file):    28016 kB
Unevictable:           0 kB
Mlocked:               0 kB
SwapTotal:             0 kB
SwapFree:              0 kB
Dirty:                12 kB
Writeback:             0 kB
AnonPages:         13980 kB
Mapped:             6652 kB
Shmem:               120 kB
Slab:              22652 kB
SReclaimable:       6856 kB
SUnreclaim:        15796 kB
KernelStack:        2504 kB
PageTables:         1240 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:       62052 kB
Committed_AS:     994308 kB
VmallocTotal:     777216 kB
VmallocUsed:       21656 kB
VmallocChunk:     727036 kB


/ # cat /proc/cpuinfo
processor       : 0
model name      : ARMv7 Processor rev 5 (v7l)
BogoMIPS        : 38.40
Features        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x0
CPU part        : 0xc07
CPU revision    : 5

Hardware        : Qualcomm Technologies, Inc MDM9650
Revision        : 0000
Serial          : 0000000000000000
Processor       : ARMv7 Processor rev 5 (v7l)




WAVE LOW :
/ # cat /proc/partitions
major minor  #blocks  name

   1        0       4096 ram0
   1        1       4096 ram1
   1        2       4096 ram2
   1        3       4096 ram3
   1        4       4096 ram4
   1        5       4096 ram5
   1        6       4096 ram6
   1        7       4096 ram7
   1        8       4096 ram8
   1        9       4096 ram9
   1       10       4096 ram10
   1       11       4096 ram11
   1       12       4096 ram12
   1       13       4096 ram13
   1       14       4096 ram14
   1       15       4096 ram15
 253        0      62024 zram0
  31        0       2560 mtdblock0
  31        1       2560 mtdblock1
  31        2      15360 mtdblock2
  31        3       5120 mtdblock3
  31        4       5120 mtdblock4
  31        5       2304 mtdblock5
  31        6       1024 mtdblock6
  31        7       1024 mtdblock7
  31        8        768 mtdblock8
  31        9       1024 mtdblock9
  31       10      10752 mtdblock10
  31       11        768 mtdblock11
  31       12      68608 mtdblock12
  31       13       1536 mtdblock13
  31       14      10752 mtdblock14
  31       15       2304 mtdblock15
  31       16        768 mtdblock16
  31       17       1024 mtdblock17
  31       18       1024 mtdblock18
  31       19       1024 mtdblock19
  31       20       1536 mtdblock20
  31       21       1536 mtdblock21
  31       22      31232 mtdblock22
  31       23        768 mtdblock23
  31       24     103424 mtdblock24
  31       25     250368 mtdblock25
  
  
  / # cat /proc/meminfo
MemTotal:         124044 kB
MemFree:           11332 kB
MemAvailable:      52260 kB
Buffers:               0 kB
Cached:            36760 kB
SwapCached:          984 kB
Active:            26368 kB
Inactive:          24932 kB
Active(anon):       8560 kB
Inactive(anon):     6180 kB
Active(file):      17808 kB
Inactive(file):    18752 kB
Unevictable:           0 kB
Mlocked:               0 kB
SwapTotal:         62020 kB
SwapFree:          58496 kB
Dirty:                 0 kB
Writeback:             0 kB
AnonPages:         13660 kB
Mapped:            12396 kB
Shmem:               200 kB
KReclaimable:       9960 kB
Slab:              38288 kB
SReclaimable:       9960 kB
SUnreclaim:        28328 kB
KernelStack:        1976 kB
PageTables:         1376 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:      124040 kB
Committed_AS:    1120016 kB
VmallocTotal:     896768 kB
VmallocUsed:       11804 kB
VmallocChunk:          0 kB
Percpu:               96 kB
CmaTotal:          12288 kB
CmaFree:            1832 kB


/ # cat /proc/cpuinfo
processor       : 0
model name      : ARMv7 Processor rev 5 (v7l)
BogoMIPS        : 38.40
Features        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x0
CPU part        : 0xc07
CPU revision    : 5

Hardware        : Qualcomm Technologies, Inc. SDXNIGHTJAR (Flattened Device Tree)
Revision        : 0000
Serial          : 0000000000000000


737 2025/07/16 18:06:24.579000 93.5133 149 WAVA TMLM TMMC 2760 log info verbose 10 [ thermal-monitor ][ ThermalMonitorService.cpp : 2081 ][ chkCloseOverTempStatus ] chkCloseOverTemp [AP:0,NAD:0] : Side = 1 temp = 40
881 2025/07/16 18:06:24.579000 94.5138 153 WAVA TMLM TMMC 2760 log info verbose 10 [ thermal-monitor ][ ThermalMonitorService.cpp : 2081 ][ chkCloseOverTempStatus ] chkCloseOverTemp [AP:0,NAD:0] : Side = 1 temp = 39
998 2025/07/16 18:06:24.579000 95.5139 157 WAVA TMLM TMMC 2760 log info verbose 10 [ thermal-monitor ][ ThermalMonitorService.cpp : 2081 ][ chkCloseOverTempStatus ] chkCloseOverTemp [AP:0,NAD:0] : Side = 1 temp = 39
2726 2025/07/16 18:06:24.679000 103.5171 190 WAVA TMLM TMMC 2760 log info verbose 10 [ thermal-monitor ][ ThermalMonitorService.cpp : 2081 ][ chkCloseOverTempStatus ] chkCloseOverTemp [AP:0,NAD:0] : Side = 1 temp = 39
2876 2025/07/16 18:06:24.679000 104.5175 194 WAVA TMLM TMMC 2760 log info verbose 10 [ thermal-monitor ][ ThermalMonitorService.cpp : 2081 ][ chkCloseOverTempStatus ] chkCloseOverTemp [AP:0,NAD:0] : Side = 1 temp = 40
2985 2025/07/16 18:06:24.695000 105.5180 198 WAVA TMLM TMMC 2760 log info verbose 10 [ thermal-monitor ][ ThermalMonitorService.cpp : 2081 ][ chkCloseOverTempStatus ] chkCloseOverTemp [AP:0,NAD:0] : Side = 1 temp = 39

C:\Users\gunturu.sai\Documents\platform-tools>adb1 -s 0123459876 shell
sh-3.2# lspci
00:00.0 PCI bridge: Freescale Semiconductor Inc Device 0000 (rev 01)
01:00.0 Unassigned class [ff00]: Qualcomm Device 0302
sh-3.2# lsusb
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub



Connects to the device's COM port (e.g., COM48) while it is in Sahara/EDL mode.

Sends the Firehose programmer (prog_emmc_firehose_8994_lite.mbn) to the device.

If successful, the device loads the Firehose and enters programming mode, where you can read/write flash via tools like fh_loader.exe.


  <program PAGES_PER_BLOCK="64" SECTOR_SIZE_IN_BYTES="4096" filename="mdm9650-sysfs.ubi" num_partition_sectors="62592" physical_partition_number="0" start_sector="68480"/> from this we can say size of nand is 244MB =num of sectors* size of sectors
  
  
  wave low:before migraition:
  
  sh-3.2# cd system
sh-3.2# cat rild.service
[Unit]
Description=RIL Daemon Service...
SourcePath=/usr/bin/rild
Before=telephonyManager.service
After=bootmode.service qrtr.service netmgrd.service dlt.service
ConditionPathExists=!/tmp/bootmode_factory_reset
ConditionPathExists=!/tmp/bootmode_download
ConditionPathExists=!/tmp/bootmode_nadtest

[Service]
Type=simple
Restart=always
EnvironmentFile=/etc/systemd/TigrisEnvironment
ExecStart=/usr/bin/rild -l libril-qc-qmi-1.so.1

[Install]
WantedBy=multi-user.target
  
  
 C:\Users\gunturu.sai\Documents\platform-tools>adb1 -s 0123459876 shell
sh-3.2# systemctl status rild.service
● rild.service - RIL Daemon Service...
   Loaded: loaded (/usr/bin/rild; enabled; vendor preset: enabled)
   Active: active (running) since Thu 2025-07-17 00:06:52 UTC; 4 days ago
 Main PID: 1601 (rild)
   CGroup: /system.slice/rild.service
           └─1601 /usr/bin/rild -l libril-qc-qmi-1.so.1
sh-3.2# ps -al
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 R     0 32502 29121  0  80   0 -  1917 -      pts/0    00:00:00 ps




wave_low after migration:

sh-3.2# cd lib/systemd/system
sh-3.2# cat rild.service
[Unit]
Description=RIL Daemon Service...
SourcePath=/usr/bin/rild
Before=telephonyManager.service
After=bootmode.service qrtr.service netmgrd.service dlt.service
ConditionPathExists=!/tmp/bootmode_factory_reset
ConditionPathExists=!/tmp/bootmode_download
ConditionPathExists=!/tmp/bootmode_nadtest

[Service]
Type=simple
Restart=always
EnvironmentFile=/etc/systemd/TigrisEnvironment
ExecStart=/usr/bin/rild -l libril-qc-qmi-1.so.1

[Install]
WantedBy=multi-user.target


● rild.service - RIL Daemon Service...
   Loaded: loaded (/usr/bin/rild; enabled; vendor preset: enabled)
   Active: active (running) since Tue 2025-07-08 02:33:05 UTC; 17s ago
 Main PID: 8676 (rild)
   CGroup: /system.slice/rild.service
           └─8676 /usr/bin/rild -l libril-qc-qmi-1.so.1
		   
		   
		   
19751 2025/07/24 14:41:29.957000 18.4694 11 WAVA TELX TELX 1978 log info verbose 8 [ [TelephonyManagerService][OemHookRawManager.cpp:2840][handleSolOemHookRaw] : 1978 : 2038 ] [PhoneId:0]:wakeup reason is not due to data disruption
19752 2025/07/24 14:41:29.957000 18.4694 12 WAVA TELX TELX 1978 log info verbose 8 [ [TelephonyManagerService][OemHookRawManager.cpp:2847][handleSolOemHookRaw] : 1978 : 2038 ] [PhoneId:0]:wakeup reason is not due to NAO no service
19758 2025/07/24 14:41:29.957000 18.4706 240 WAVA PWRH PWRH 1945 log info verbose 11 [ PowerModeHandler ][ PowerModeHandler.cpp : 3024 ][ onRadioStateChanged ]  : get NAD wakeup_reason =  0x03000000

18608 2025/07/24 14:58:16.493000 18.3876 40 WAVA TELX TELX 2003 log info verbose 8 [ [TelephonyManagerService][OemHookRawManager.cpp:2840][handleSolOemHookRaw] : 2003 : 2046 ] [PhoneId:0]:wakeup reason is not due to data disruption
18609 2025/07/24 14:58:16.493000 18.3876 41 WAVA TELX TELX 2003 log info verbose 8 [ [TelephonyManagerService][OemHookRawManager.cpp:2847][handleSolOemHookRaw] : 2003 : 2046 ] [PhoneId:0]:wakeup reason is not due to NAO no service



C:\Users\gunturu.sai\Documents\platform-tools>adb1 -s 0123459876 root
adbd is already running as root

C:\Users\gunturu.sai\Documents\platform-tools>adb1 -s 0123459876 remount
remount succeeded

sh-3.2#  cat /sys/power/system_sleep/stats
cat: can't open '/sys/power/system_sleep/stats': No such file or directory
sh-3.2#
sh-3.2#  cat /sys/kernel/debug/suspend_stats
success: 0
fail: 0
failed_freeze: 0
failed_prepare: 0
failed_suspend: 0
failed_suspend_late: 0
failed_suspend_noirq: 0
failed_resume: 0
failed_resume_early: 0
failed_resume_noirq: 0
failures:
  last_failed_dev:

  last_failed_errno:    0
                        0
  last_failed_step:



sh-3.2#   cat /sys/power/system_sleep/stats
cat: can't open '/sys/power/system_sleep/stats': No such file or directory
sh-3.2#   cat /sys/kernel/debug/suspend_stats
success: 0
fail: 0
failed_freeze: 0
failed_prepare: 0
failed_suspend: 0
failed_suspend_late: 0
failed_suspend_noirq: 0
failed_resume: 0
failed_resume_early: 0
failed_resume_noirq: 0
failures:
  last_failed_dev:

  last_failed_errno:    0
                        0
  last_failed_step:
  
  
  
  sh-3.2# cat /sys/power/rpmh_stats/master_stats
at /sys/power/system_sleep/stats
  cat /sys/kernel/debug/suspend_statscat: can't open '/sys/power/rpmh_stats/master_stats': No such file or directory
sh-3.2#   cat /sys/power/system_sleep/stats
cat: can't open '/sys/power/system_sleep/stats': No such file or directory
sh-3.2#   cat /sys/kernel/debug/suspend_stats
success: 1
fail: 0
failed_freeze: 0
failed_prepare: 0
failed_suspend: 0
failed_suspend_late: 0
failed_suspend_noirq: 0
failed_resume: 0
failed_resume_early: 0
failed_resume_noirq: 0
failures:
  last_failed_dev:

  last_failed_errno:    0
                        0
  last_failed_step:



/sys/kernel/debug # cat wakeup_sources
name            active_count    event_count     wakeup_count    expire_count    active_since    total_time      max_timelast_change     prevent_suspend_time
msm_wmapro      0               0               0               0               0               0               0
0               0
msm_wma         0               0               0               0               0               0               0
0               0
msm_qcelp       0               0               0               0               0               0               0
0               0
msm_multi_aac   0               0               0               0               0               0               0
0               0
msm_mp3         0               0               0               0               0               0               0
0               0
msm_g711mlaw    0               0               0               0               0               0               0
0               0
msm_g711alaw    0               0               0               0               0               0               0
0               0
msm_evrc        0               0               0               0               0               0               0
0               0
msm_ape         0               0               0               0               0               0               0
0               0
msm_amrwbplus   0               0               0               0               0               0               0
0               0
msm_amrwb       0               0               0               0               0               0               0
0               0
msm_amrnb       0               0               0               0               0               0               0
0               0
msm_alac        0               0               0               0               0               0               0
0               0
msm_aac         0               0               0               0               0               0               0
0               0
spkr-prot       0               0               0               0               0               0               0
0               0
power_manager_daemon    1               1               0               0               16011           16011          16011            28673           11288
qwesd_qmi_wakelock      1               1               0               0               0               969            969              21637           0
qwesd_exp_wakelock      1               1               0               0               0               1078           1078             21742           0
IPA_CLIENT_APPS_WAN_CONS        0               0               0               0               0               0
0               0               0
qrtr_ws         1               2067            0               0               29116           29116           29116
15568           11288
qrtr_ws         3               649             0               2               27599           28675           27599
17085           11288
MODEM (MHI)     0               0               0               0               0               0               0
0               0
MHI             0               0               0               0               0               0               0
0               0
ssr(modem)      0               0               0               0               0               0               0
0               0
pil-modem       1               1               0               0               0               6580            6580
15563           0
a600000.ssusb   1               1               0               0               43928           43928           43928
756             11288
IPA_CLIENT_MEMCPY_DMA_ASYNC_CONS        14              14              0               0               15319          29947            15319           29365           11288
IPA_CLIENT_MEMCPY_DMA_SYNC_CONS 0               0               0               0               0               0
0               0               0
lge_ws          0               0               0               0               0               0               0
0               0
soc:qcom,pmd-vbus-det   0               0               0               0               0               0              0        0               0
alarmtimer      0               0               0               0               0               0               0
0               0
c440000.qcom,spmi:qcom,pmx55@8:qcom,rtc@6000    0               0               0               0               0
0               0               0               0
ff0000.qcom,msm-eud     0               0               0               0               0               0              0        0               0
smp2p           5               5               0               0               0               0               0
15823           0
ssr(ipa_fws)    0               0               0               0               0               0               0
0               0
pil-ipa_fws     0               0               0               0               0               0               0
0               0
rmnet_ipa%d     0               0               0               0               0               0               0
0               0
TETH MODEM      0               0               0               0               0               0               0
0               0
EMB MODEM       0               0               0               0               0               0               0
0               0
IPA_CLIENT_APPS_LAN_CONS        1               1               0               0               0               147
147             552             0
ODL             0               0               0               0               0               0               0
0               0
IPA_WS          1178            1178            0               0               0               2650            45
44601           360
1c03000.mhi_dev 1               1               0               0               44366           44366           44366
318             11288
40002000.qcom,pcie      1               1               0               0               44090           44090          44090            594             11288
c440000.qcom,spmi:qcom,pmx55@8:qcom,power-on@800        0               0               0               0              0        0               0               0               0
lge_pm_ws       0               0               0               0               0               0               0
0               0
autosleep       1               1               0               0               0               0               0
33396           0
deleted         0               0               0               0               0               0               0




Check cat /sys/kernel/debug/clk/clk_summary | grep uart — see if UART clocks are ON.


if it is on then uart clock will be on


   522.281196:   <2> Resume caused by IRQ 38, smp2p   ---> it is triggered by pressing the forced_usb_boot in debug board.


✅ If IRQ 38 comes, it means the modem is waking or notifying the Application Processor (AP/Linux) — not the AP waking the modem.

🔁 Understanding SMP2P Flow (Modem ↔ APSS):
📲 Who sends IRQ 38?
The modem (or another remote processor) writes to shared memory (SMEM)

That triggers an interrupt (IRQ 38) on the Application Processor (APSS)

The smp2p driver in Linux handles it

🔄 Use-case Example:
Modem signals “I'm ready”
Modem writes "modem_ready" flag to SMEM

SMP2P firmware logic triggers IRQ 38

AP/Linux (via smp2p driver) receives the interrupt

Driver reads flag → informs other Linux drivers (e.g., IPA, QMI, etc.)

🧠 Summary:
Event	Trigger	Action
IRQ 38	From modem → AP	smp2p driver reads SMEM, reacts
Waking modem	Done via other mechanisms like power-on, QMI request, etc.	Not triggered via IRQ 38




[[0;1;31mWarning:[[0m The unit file, source configuration file or drop-ins of lo
cation_hal_daemon.service changed on disk. Run 'systemctl daemon-reload' to relo
ad units.
[[0;1;32m*[[0m location_hal_daemon.service - location remote service launcher
     Loaded: loaded (/usr/bin/location_hal_daemon; enabled; vendor preset: disab
led)
    Drop-In: /etc/systemd/system/location_hal_daemon.service.d
             `-location_hal_daemon.conf, location_hal_daemon_auto.conf
     Active: [[0;1;32mactive (running)[[0m since Sun 1980-01-06 00:00:08 UTC; 2s
 ago
    Process: 818 ExecStartPost=/bin/sleep 5 (code=exited, status=0/SUCCESS)
   Main PID: 817 (location_hal_da)
     CGroup: /system.slice/location_hal_daemon.service
             `-817 /usr/bin/location_hal_daemon

~
~
~
~
~
~
~
~
standard input
C:\Users\gunturu.sai\Documents\platform-tools>
C:\Users\gunturu.sai\Documents\platform-tools>adb1 shell
/ # systemctl status location_hal_daemon.service




/ $ cat /proc/iomem
00000000-00000000 : 20000.qcom,ethernet stmmaceth
00000000-00000000 : 20000.qcom,ethernet rgmii
00000000-00000000 : 100000.clock-controller cc_base
00000000-00000000 : msm_serial
00000000-00000000 : msm_serial
00000000-00000000 : spi_qsd
00000000-00000000 : 837000.i2c
00000000-00000000 : ff0000.qcom,msm-eud eud_base
00000000-00000000 : ff4000.hsphy hsusb_phy_base
00000000-00000000 : ff6000.ssphy pcs_clamp_enable_reg
00000000-00000000 : stm-base
  00000000-00000000 : 6002000.stm stm-base
00000000-00000000 : tpda-base
  00000000-00000000 : 6004000.tpda tpda-base
00000000-00000000 : funnel-base
  00000000-00000000 : 6005000.funnel funnel-base
00000000-00000000 : cti-base
  00000000-00000000 : 6010000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6011000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6012000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6013000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6014000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6015000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6016000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6017000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6018000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6019000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 601a000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 601b000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 601c000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 601d000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 601e000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 601f000.cti cti-base
00000000-00000000 : funnel-base
  00000000-00000000 : 6041000.funnel funnel-base
00000000-00000000 : funnel-base
  00000000-00000000 : 6042000.funnel funnel-base
00000000-00000000 : funnel-base
  00000000-00000000 : 6045000.funnel funnel-base
00000000-00000000 : replicator-base
  00000000-00000000 : 6046000.replicator replicator-base
00000000-00000000 : tmc-base
  00000000-00000000 : 6048000.tmc tmc-base
00000000-00000000 : tpdm-base
  00000000-00000000 : 6800000.tpdm tpdm-base
00000000-00000000 : tpda-base
  00000000-00000000 : 6803000.tpda tpda-base
00000000-00000000 : funnel-base
  00000000-00000000 : 6804000.funnel funnel-base
00000000-00000000 : funnel-base-dummy
00000000-00000000 : funnel-base
  00000000-00000000 : 680c000.funnel funnel-base
00000000-00000000 : tpdm-base
  00000000-00000000 : 6840000.tpdm tpdm-base
00000000-00000000 : tpdm-base
  00000000-00000000 : 6870000.tpdm tpdm-base
00000000-00000000 : tpdm-base
  00000000-00000000 : 69e0000.tpdm tpdm-base
00000000-00000000 : cti-base
  00000000-00000000 : 69e1000.cti cti-base
00000000-00000000 : funnel-base
  00000000-00000000 : 69e2000.funnel funnel-base
00000000-00000000 : cti-base
  00000000-00000000 : 69e4000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 69e5000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 69e6000.cti cti-base
00000000-00000000 : tpda-base
  00000000-00000000 : 6b01000.tpda tpda-base
00000000-00000000 : tpdm-base
  00000000-00000000 : 6b02000.tpdm tpdm-base
00000000-00000000 : tpdm-base
  00000000-00000000 : 6b03000.tpdm tpdm-base
00000000-00000000 : cti-base
  00000000-00000000 : 6b04000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6b05000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6b06000.cti cti-base
00000000-00000000 : cti-base
  00000000-00000000 : 6b07000.cti cti-base
00000000-00000000 : funnel-base
  00000000-00000000 : 6b08000.funnel funnel-base
00000000-00000000 : tmc-base
  00000000-00000000 : 6b09000.tmc tmc-base
00000000-00000000 : replicator-base
  00000000-00000000 : 6b0a000.replicator replicator-base
00000000-00000000 : tgu-base
  00000000-00000000 : 6b0c000.tgu tgu-base
00000000-00000000 : tpdm-base
  00000000-00000000 : 6c28000.tpdm tpdm-base
00000000-00000000 : etm@7002000
  00000000-00000000 : 7002000.etm etm@7002000
00000000-00000000 : cti-base
  00000000-00000000 : 7003000.cti cti-base
00000000-00000000 : a600000.dwc3 dwc3@a600000
00000000-00000000 : c222000.tsens tsens_srot_physical
00000000-00000000 : c222000.tsens tsens_tm_physical
00000000-00000000 : c264000.restart pshold-base
00000000-00000000 : spmi-0 cnfg
00000000-00000000 : spmi-0 core
00000000-00000000 : spmi-0 chnls
00000000-00000000 : spmi-0 obsrvr
00000000-00000000 : spmi-0 intr
00000000-00000000 : f100000.pinctrl pinctrl
00000000-00000000 : 15000000.apps-smmu base
00000000-00000000 : 15000000.apps-smmu tcu-base
00000000-00000000 : 15025000.periph_tbu status-reg
00000000-00000000 : 15029000.ipa_tbu status-reg
00000000-00000000 : 15025000.periph_tbu base
00000000-00000000 : 15029000.ipa_tbu base
00000000-00000000 : 6002000.stm stm-stimulus-base
00000000-00000000 : 17810008.clock-controller apcs_pll
00000000-00000000 : 17810008.clock-controller apcs_cmd
00000000-00000000 : 17811000.mailbox mailbox@0x17811000
00000000-00000000 : 17817000.qcom,wdt wdt-base
00000000-00000000 : arch_mem_timer
00000000-00000000 : 17830000.rsc drv-1
00000000-00000000 : System RAM
  00000000-00000000 : Kernel code
  00000000-00000000 : Kernel data
00000000-00000000 : System RAM
00000000-00000000 : System RAM
00000000-00000000 : System RAM
00000000-00000000 : System RAM
00000000-00000000 : System RAM

C:\Users\gunturu.sai\Documents\platform-tools>adb1 shell
/ # cat /proc/slabinfo
slabinfo - version: 2.1
# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> : tunables <limit> <batchcount> <sharedfactor> : slabdata <active_slabs> <num_slabs> <sharedavail>
zs_handle            512    512      8  512    1 : tunables    0    0    0 : slabdata      1      1      0
ubifs_inode_slab    1166   1248    680   12    2 : tunables    0    0    0 : slabdata    104    104      0
L2TP/IP                0      0    960    8    2 : tunables    0    0    0 : slabdata      0      0      0
ip6-frags              0      0    160   25    1 : tunables    0    0    0 : slabdata      0      0      0
PINGv6                 0      0   1088   15    4 : tunables    0    0    0 : slabdata      0      0      0
RAWv6                 15     15   1088   15    4 : tunables    0    0    0 : slabdata      1      1      0
UDPv6                 14     14   1152   14    4 : tunables    0    0    0 : slabdata      1      1      0
tw_sock_TCPv6          0      0    216   18    1 : tunables    0    0    0 : slabdata      0      0      0
request_sock_TCPv6      0      0    264   15    1 : tunables    0    0    0 : slabdata      0      0      0
TCPv6                 15     15   2176   15    8 : tunables    0    0    0 : slabdata      1      1      0
nf_conntrack_expect      0      0    176   23    1 : tunables    0    0    0 : slabdata      0      0      0
nf_conntrack           0      0    320   12    1 : tunables    0    0    0 : slabdata      0      0      0
lkdtm-heap-b           0      0     72   56    1 : tunables    0    0    0 : slabdata      0      0      0
lkdtm-heap-a           0      0     72   56    1 : tunables    0    0    0 : slabdata      0      0      0
lkdtm-heap-double_free      0      0     72   56    1 : tunables    0    0    0 : slabdata      0      0      0
lkdtm-usercopy         0      0   1024    8    2 : tunables    0    0    0 : slabdata      0      0      0
sgpool-128            12     12   2560   12    8 : tunables    0    0    0 : slabdata      1      1      0
sgpool-64             12     12   1280   12    4 : tunables    0    0    0 : slabdata      1      1      0
sgpool-32             12     12    640   12    2 : tunables    0    0    0 : slabdata      1      1      0
ovl_inode              0      0    584   14    2 : tunables    0    0    0 : slabdata      0      0      0
fat_inode_cache        0      0    640   12    2 : tunables    0    0    0 : slabdata      0      0      0
fat_cache              0      0     24  170    1 : tunables    0    0    0 : slabdata      0      0      0
jbd2_transaction_s      0      0    192   21    1 : tunables    0    0    0 : slabdata      0      0      0
jbd2_journal_head      0      0     64   64    1 : tunables    0    0    0 : slabdata      0      0      0
ext4_inode_cache       0      0    976    8    2 : tunables    0    0    0 : slabdata      0      0      0
ext4_allocation_context      0      0    104   39    1 : tunables    0    0    0 : slabdata      0      0      0
ext4_prealloc_space      0      0     80   51    1 : tunables    0    0    0 : slabdata      0      0      0
ext4_io_end            0      0     48   85    1 : tunables    0    0    0 : slabdata      0      0      0
ext4_pending_reservation      0      0     16  256    1 : tunables    0    0    0 : slabdata      0      0      0
ext4_extent_status      0      0     32  128    1 : tunables    0    0    0 : slabdata      0      0      0
mbcache                0      0     40  102    1 : tunables    0    0    0 : slabdata      0      0      0
dio                    0      0    352   11    1 : tunables    0    0    0 : slabdata      0      0      0
posix_timers_cache     20     20    200   20    1 : tunables    0    0    0 : slabdata      1      1      0
PING                 132    135    896    9    2 : tunables    0    0    0 : slabdata     15     15      0
RAW                    8      8    960    8    2 : tunables    0    0    0 : slabdata      1      1      0
UDP                    8      8   1024    8    2 : tunables    0    0    0 : slabdata      1      1      0
tw_sock_TCP            0      0    216   18    1 : tunables    0    0    0 : slabdata      0      0      0
request_sock_TCP       0      0    264   15    1 : tunables    0    0    0 : slabdata      0      0      0
TCP                    8      8   2048    8    4 : tunables    0    0    0 : slabdata      1      1      0
IPA_HDR_PROC_CTX     448    448     72   56    1 : tunables    0    0    0 : slabdata      8      8      0
IPA_HDR               19     19    208   19    1 : tunables    0    0    0 : slabdata      1      1      0
IPA_RT                18     18    224   18    1 : tunables    0    0    0 : slabdata      1      1      0
IPA_FLT                0      0    416   19    2 : tunables    0    0    0 : slabdata      0      0      0
request_queue         72     72   1712    9    4 : tunables    0    0    0 : slabdata      8      8      0
blkdev_ioc            39     39    104   39    1 : tunables    0    0    0 : slabdata      1      1      0
biovec-max           140    140   3072   10    8 : tunables    0    0    0 : slabdata     14     14      0
biovec-128             0      0   1536   10    4 : tunables    0    0    0 : slabdata      0      0      0
QIPCRTR              130    130    768   10    2 : tunables    0    0    0 : slabdata     13     13      0
sock_inode_cache     295    312    640   12    2 : tunables    0    0    0 : slabdata     26     26      0
skbuff_fclone_cache      0      0    448    9    1 : tunables    0    0    0 : slabdata      0      0      0
skbuff_head_cache    457    576    256   16    1 : tunables    0    0    0 : slabdata     36     36      0
file_lock_cache       24     24    168   24    1 : tunables    0    0    0 : slabdata      1      1      0
net_namespace          0      0   2240   14    8 : tunables    0    0    0 : slabdata      0      0      0
proc_dir_entry       320    320    128   32    1 : tunables    0    0    0 : slabdata     10     10      0
proc_inode_cache     527    574    560   14    2 : tunables    0    0    0 : slabdata     41     41      0
seq_file              84     84     96   42    1 : tunables    0    0    0 : slabdata      2      2      0
bdev_cache            70     70    768   10    2 : tunables    0    0    0 : slabdata      7      7      0
shmem_inode_cache   1022   1027    600   13    2 : tunables    0    0    0 : slabdata     79     79      0
kernfs_iattrs_cache   2698   2703     80   51    1 : tunables    0    0    0 : slabdata     53     53      0
kernfs_node_cache  37809  37884     96   42    1 : tunables    0    0    0 : slabdata    902    902      0
inode_cache        12622  12630    520   15    2 : tunables    0    0    0 : slabdata    842    842      0
dentry             15502  17064    168   24    1 : tunables    0    0    0 : slabdata    711    711      0
names_cache            9     24   4096    8    8 : tunables    0    0    0 : slabdata      3      3      0
avtab_extended_perms    257    306     40  102    1 : tunables    0    0    0 : slabdata      3      3      0
avc_xperms_decision_node    170    170     24  170    1 : tunables    0    0    0 : slabdata      1      1      0
avc_node             218    219     56   73    1 : tunables    0    0    0 : slabdata      3      3      0
iint_cache             0      0     88   46    1 : tunables    0    0    0 : slabdata      0      0      0
lsm_file_cache      1408   1536     16  256    1 : tunables    0    0    0 : slabdata      6      6      0
key_jar              234    252    192   21    1 : tunables    0    0    0 : slabdata     12     12      0
buffer_head           64     64     64   64    1 : tunables    0    0    0 : slabdata      1      1      0
vm_area_struct      3561   4080    136   30    1 : tunables    0    0    0 : slabdata    136    136      0
mm_struct             50     70    576   14    2 : tunables    0    0    0 : slabdata      5      5      0
signal_cache         144    187    704   11    2 : tunables    0    0    0 : slabdata     17     17      0
sighand_cache        141    180   1344   12    4 : tunables    0    0    0 : slabdata     15     15      0
task_struct          321    340   1856   17    8 : tunables    0    0    0 : slabdata     20     20      0
cred_jar             315    416    128   32    1 : tunables    0    0    0 : slabdata     13     13      0
anon_vma            1269   1632     80   51    1 : tunables    0    0    0 : slabdata     32     32      0
pid                  465    512     64   64    1 : tunables    0    0    0 : slabdata      8      8      0
trace_event_file   16908  18700     48   85    1 : tunables    0    0    0 : slabdata    220    220      0
pool_workqueue      1684   1872    256   16    1 : tunables    0    0    0 : slabdata    117    117      0
radix_tree_node     1623   1664    304   13    1 : tunables    0    0    0 : slabdata    128    128      0
task_group            12     12    320   12    1 : tunables    0    0    0 : slabdata      1      1      0
vmap_area           6931   7808     32  128    1 : tunables    0    0    0 : slabdata     61     61      0
kmalloc-rcl-8k         0      0   8192    4    8 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-4k         0      0   4096    8    8 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-2k         0      0   2048    8    4 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-1k         0      0   1024    8    2 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-512        0      0    512    8    1 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-256        0      0    256   16    1 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-192        0      0    192   21    1 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-128       34     64    128   32    1 : tunables    0    0    0 : slabdata      2      2      0
kmalloc-rcl-64        64    128     64   64    1 : tunables    0    0    0 : slabdata      2      2      0
kmalloc-8k           474    476   8192    4    8 : tunables    0    0    0 : slabdata    119    119      0
kmalloc-4k          1691   1696   4096    8    8 : tunables    0    0    0 : slabdata    212    212      0
kmalloc-2k           239    240   2048    8    4 : tunables    0    0    0 : slabdata     30     30      0
kmalloc-1k          1576   1720   1024    8    2 : tunables    0    0    0 : slabdata    216    216      0
kmalloc-512          723    904    512    8    1 : tunables    0    0    0 : slabdata    113    113      0
kmalloc-256         1670   2224    256   16    1 : tunables    0    0    0 : slabdata    139    139      0
kmalloc-192          864    903    192   21    1 : tunables    0    0    0 : slabdata     43     43      0
kmalloc-128         4494   4512    128   32    1 : tunables    0    0    0 : slabdata    141    141      0
kmalloc-64         30203  30272     64   64    1 : tunables    0    0    0 : slabdata    473    473      0
kmem_cache_node      128    128     64   64    1 : tunables    0    0    0 : slabdata      2      2      0
kmem_cache           105    105    192   21    1 : tunables    0    0    0 : slabdata      5      5      0


/ # cat /proc/slabinfo |grep kmalloc
kmalloc-rcl-8k         0      0   8192    4    8 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-4k         0      0   4096    8    8 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-2k         0      0   2048    8    4 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-1k         0      0   1024    8    2 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-512        0      0    512    8    1 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-256        0      0    256   16    1 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-192        0      0    192   21    1 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-rcl-128       33     64    128   32    1 : tunables    0    0    0 : slabdata      2      2      0
kmalloc-rcl-64        96    128     64   64    1 : tunables    0    0    0 : slabdata      2      2      0
kmalloc-8k           474    476   8192    4    8 : tunables    0    0    0 : slabdata    119    119      0
kmalloc-4k          1691   1696   4096    8    8 : tunables    0    0    0 : slabdata    212    212      0
kmalloc-2k           240    240   2048    8    4 : tunables    0    0    0 : slabdata     30     30      0
kmalloc-1k          1577   1744   1024    8    2 : tunables    0    0    0 : slabdata    218    218      0
kmalloc-512          731    928    512    8    1 : tunables    0    0    0 : slabdata    116    116      0
kmalloc-256         1538   1856    256   16    1 : tunables    0    0    0 : slabdata    116    116      0
kmalloc-192          863    882    192   21    1 : tunables    0    0    0 : slabdata     42     42      0
kmalloc-128         4461   4512    128   32    1 : tunables    0    0    0 : slabdata    141    141      0
kmalloc-64         30195  30400     64   64    1 : tunables    0    0    0 : slabdata    475    475      0



“Whenever kernel accesses memory, the CPU uses virtual addresses first. These virtual addresses are translated via the MMU into physical addresses, which then access the RAM.”

kmalloc()

Allocates memory from low memory (directly mapped part of RAM).

The allocated memory is physically contiguous.

Example: kmalloc(4 KB, GFP_KERNEL) → returns a pointer to a contiguous 4 KB region in RAM.

vmalloc()

Allocates memory that is contiguous in virtual address space but may be fragmented physically.

The kernel creates page table entries so that scattered physical pages appear contiguous in virtual addresses.

High memory (ZONE_HIGHMEM)

Some physical RAM is not permanently mapped in the kernel’s virtual address space (highmem).

kmalloc() usually cannot use highmem directly.

vmalloc() (or kmap()) can temporarily map highmem pages to virtual addresses for kernel access


physical adresss has frame number and virtual address has page table is this correct
ChatGPT said:

You’re very close, but let’s correct and clarify it properly 👇

🧠 Physical Address vs Virtual Address
Concept	Description	Contains / Associated With
Physical Address	The actual address in RAM (hardware memory) where data is stored. CPU accesses this address after address translation.	✅ Refers to frames (physical memory frames).
Virtual Address	The address used by user processes or kernel code — this is what your program sees.	✅ Refers to pages (virtual pages) which are mapped to physical frames through page tables.
📘 Correct Explanation

Virtual Address → Page Table → Physical Address

When a process accesses memory:

The virtual address is divided into:

Page number → index into the page table.

Offset → offset within that page.

The page table entry gives the frame number (in physical memory).

Combine frame number + offset → physical address.

✅ So, in short:

🔹 Virtual address → has page number (uses page tables)
🔹 Physical address → has frame number (actual RAM location)

Would you like me to show a small diagram of this translation (virtual → physical) using page/frame numbers? It helps visualize it perfectly.

You said:
ptage table converts virtual address to page frame number
ChatGPT said:

✅ Exactly right — just to make it perfectly clear and precise:

The page table converts a virtual page number (VPN) into a physical frame number (PFN).

🧠 In detail:

When the CPU accesses memory:

The virtual address is split into:

Virtual Page Number (VPN) — used as an index into the page table.

Page Offset — offset inside that page.

The page table entry (PTE) gives:

The Physical Frame Number (PFN) (the corresponding frame in RAM).

Access bits (valid, dirty, read/write, etc.).

The physical address is then formed as:

Physical Address = (PFN << page_offset_bits) + offset

🔁 Summary:
Step	Input	Output
1️⃣	Virtual Address	VPN + Offset
2️⃣	Page Table	Maps VPN → PFN
3️⃣	Combine	PFN + Offset → Physical Address

So yes — your line is conceptually right.


Aspect	kmalloc()	vmalloc()
Physical memory	Contiguous	Can be fragmented
Virtual memory	Contiguous	Contiguous
Use case	Small buffers, DMA	Large buffers, non-DMA
Speed	Faster (direct mapping)	Slightly slower (needs page table walk)
Limitations	Limited by lowmem	Can allocate bigger chunks (~hundreds of MB)


In the Linux kernel, the slab allocator is one of the primary mechanisms for allocating memory for frequently used kernel objects

Slab caches improve allocation efficiency, reduce fragmentation, and provide object reuse for frequently used kernel structures

These are kernel internal objects, and you generally never allocate them with normal kmalloc—the slab takes care of them.

kmem_cache_create()
    ↓
Create cache metadata (struct kmem_cache)
    ↓
Prepare empty slab list

kmem_cache_alloc()
    ↓
Check partial slabs → if empty → alloc_pages()
    ↓
Split pages into objects
    ↓
Return kernel virtual address to object




C:\Users\gunturu.sai\Documents\platform-tools>adb1 shell
/ # cat /proc/buddyinfo
Node 0, zone   Normal     30    160    140     46     20     10      5      2      1      2      8





+----------------------------------------------------+
|                    User Space (AP)                 |
|----------------------------------------------------|
|  QMI Clients (wpa_supplicant, imsdaemon, rild, etc)|
+----------------------------------------------------+
|                    Kernel Space (AP)               |
|----------------------------------------------------|
|          QRTR Sockets (AF_QRTR) Interface           |
|----------------------------------------------------|
|                 QRTR Protocol Layer                 |
|       (Routing messages to modem services)          |
+----------------------------------------------------+
|           Transport (between AP & Modem)            |
|----------------------------------------------------|
|   MHI Driver (Modem Host Interface over PCIe)       |
|   GLINK / SMEM (on SoC without PCIe)                |
+----------------------------------------------------+
|                 Physical Layer                      |
|----------------------------------------------------|
|   PCIe Link (AP <--> Modem as PCIe Endpoint)        |
+----------------------------------------------------+
|                      Modem                          |
|----------------------------------------------------|
|   QRTR Services (QMI servers: DMS, WMS, IMS, PDC)   |
+----------------------------------------------------+


| Concept         | Analogy        | Role                                                        |
| --------------- | -------------- | ----------------------------------------------------------- |
| **PCIe**        | Railway Tracks | Provides physical connectivity & transport                  |
| **MHI**         | Train System   | Manages logical channels over PCIe                          |
| **QRTR**        | Station Master | Decides which passenger (IMS, WMS, etc.) boards which train |
| **QMI Service** | The Passenger  | Actual service data (IMS, DMS, SMS) traveling               |



Think of it like this:

Softirq = many teachers in a school can check assignments at once (fast, but they may fight over the same paper).

Tasklet = each paper is assigned to exactly one teacher, so no two teachers fight over the same paper (safe, but slightly slower).


tasklet is created because softirq will can create deadlock
ChatGPT said:

You’ve caught the right intuition 👍 — tasklets exist because directly using softirqs everywhere can create deadlocks or complexity. Let’s break this down clearly:

🔹 1. Softirq basics

Softirqs are low-level bottom halves in Linux.

They are statically allocated (only 10 softirq vectors exist, like HI_SOFTIRQ, NET_RX_SOFTIRQ, TASKLET_SOFTIRQ, etc).

They run in softirq context after hardware IRQs are done.

They are allowed to run on multiple CPUs simultaneously.

👉 Problem: This means if you schedule the same softirq on multiple CPUs, you must protect shared data with locks → risk of deadlocks & heavy contention.

🔹 2. Why tasklets were introduced

A tasklet is just a specialized softirq with extra rules:

Runs in softirq context (specifically TASKLET_SOFTIRQ).

Serialized per tasklet: The same tasklet (same function + data) will never run in parallel on two CPUs.

If CPU0 is running it, CPU1 won’t run it at the same time.

Different tasklets can run concurrently on different CPUs, but one tasklet is single-threaded.

✅ This prevents deadlocks & race conditions without needing explicit locks inside the tasklet code.

🔹 3. Deadlock example (if we only used raw softirq)

Imagine:

CPU0 and CPU1 both raise NET_RX_SOFTIRQ.

Both try to process the same packet queue at the same time.

If locks aren’t perfect, you can get deadlocks or starvation.

💡 With tasklets, that queue processing can be wrapped in a tasklet, ensuring that only one CPU runs that handler at a time → no deadlock.





Here’s a clear way to visualize how tasklets, softirqs, CPUs, and PIDs relate:

CPU 0                      CPU 1
-------                    -------
ksoftirqd/0 (PID 42)       ksoftirqd/1 (PID 43)
      |                          |
      |--- runs softirqs          |--- runs softirqs
      |                          |
      |--- runs tasklets          |--- runs tasklets
      |                          |
      v                          v
current->pid = 42            current->pid = 43
current->comm = "ksoftirqd/0" current->comm = "ksoftirqd/1"


Key points:

Tasklets don’t have their own PID — they inherit the PID of the kernel thread (ksoftirqd/<CPU>) that executes them.

On each CPU, the PID is fixed for the ksoftirqd thread.

current->comm also reflects the kernel thread (ksoftirqd/<CPU>), so it’s the same for all tasklets running on that CPU.

Across CPUs, the PID differs because each CPU has its own ksoftirqd thread.

This is why re-running a tasklet on the same CPU doesn’t change PID, but running it on another CPU will show a different PID.



1. You schedule a tasklet
tasklet_schedule(&my_tasklet);


This marks the tasklet as pending and calls

raise_softirq(TASKLET_SOFTIRQ);


Nothing runs immediately — only the softirq bit is set.

2. Kernel notices pending softirqs

After the interrupt handler returns (or in ksoftirqd context), the kernel calls:

do_softirq();


This function checks all pending softirq bits.

3. Softirq dispatcher

do_softirq() finds that TASKLET_SOFTIRQ is pending.

During boot, this ID was registered with:

open_softirq(TASKLET_SOFTIRQ, tasklet_action);


So it calls:

tasklet_action();

4. Tasklet core handler

tasklet_action() is the main function that handles normal-priority tasklets.

It internally calls:

tasklet_action_common(&list);


where list is the per-CPU pending tasklet list (tasklet_vec).

5. Execute your handler

tasklet_action_common() dequeues each pending tasklet and runs:

t->func(t->data);


before writing both have same virtual address and physical address
ChatGPT said:

Yes, exactly — before any write occurs:

Virtual addresses: Parent and child see the same addresses for code and data.

Physical memory: Both point to the same physical pages.

Access mode: The pages are usually marked read-only so that any write triggers a Copy-On-Write.

After one process writes to a page:

The kernel allocates a new physical page for that process.

The virtual address in that process now maps to the new page, while the other process continues using the original page.



int sem_wait(sem_t *sem) {
    while (1) {
        // Try to decrement the semaphore atomically
        if (atomic_decrement_if_positive(&sem->value)) {
            return 0; // Successfully locked
        }
        // If value was 0, block the thread until semaphore becomes available
        wait_on_semaphore_queue(sem);
    }
    return -1; // on error
}

int sem_post(sem_t *sem) {
    atomic_increment(&sem->value);    // Increment semaphore value atomically
    wake_up_one_waiting_thread(sem);  // Wake up one thread waiting in sem_wait
    return 0;
}

-----------------------------------------------------------------------------------------------------------------------------------------------
c learning

Do not apply the sizeof operator to a pointer when taking the size of an array. The sizeof operator yields the size (in bytes) of its operand, which can be an expression or the parenthesized name of a type. However, using the sizeof operator to determine the size of arrays is error prone.



Array name gives the address of first element in array. So when we do '*ptr1 = arr;', ptr1 starts holding the address of element 10. 'arr + 5' gives the address of 6th element as arithmetic is done using pointers. So 'ptr2-ptr1' gives 5. When we do '(char *)ptr2', ptr2 is type-casted to char pointer and size of character is one byte, pointer arithmetic happens considering character pointers. So we get 5*sizeof(int)/sizeof(char) as a difference of two pointers.

There is compiler error in line "printf("%d", *ptr);". void * type pointers cannot be de-referenced. We must type cast them before de-referencing.

#include <stdio.h>

int main()
{
 int var;  /*Suppose address of var is 2000 */

 void *ptr = &var;
 *ptr = 5;
//  printf("var=%d and *ptr=%d",var,*ptr);
             
 return 0;
}

/tmp/EDF3BiK7KW/main.c: In function 'main':
/tmp/EDF3BiK7KW/main.c:9:2: warning: dereferencing 'void *' pointer
    9 |  *ptr = 5;
      |  ^~~~
/tmp/EDF3BiK7KW/main.c:9:7: error: invalid use of void expression
    9 |  *ptr = 5;
	
	
	#include <stdio.h>

int main()
{
char g[] = "geeksforgeeks";

 printf("%s", g+8);
             
 return 0;
}

output:
geeks

The volatile keyword tells the compiler:

"This variable can change at any time, without any action by the code the compiler sees. Don’t assume anything about its value — always reload it from memory when accessed

volatile int flag = 0;

void loop() {
    while (flag == 0) {
        // do something
    }
}
What happens without volatile?
The compiler might optimize the loop like this:

c
Copy
Edit
if (flag == 0) {
    while (1) {
        // infinite loop, compiler assumes flag never changes
    }
}
he compiler only knows about the code written in your .c file (or visible headers).
It has no idea what other things might change memory outside your current C code — like:
t
Interrupts (ISRs)

Another CPU core or thread

Hardware (like sensors writing to a memory address)

DMA (Direct Memory Access)

Assembly instructions in a different translation unit

Memory-mapped peripherals


int x = 5;
volatile int flag = x;
flag = x;

compiler will not optimize it

mov eax, 5
mov [flag], eax
mov [flag],eax


int x = 5;
int flag = x;
flag = x;

int x = 5;
int flag = 5;
 
 without volatiloe compiler will optimize it
 
 
 
 write → the system call used by printf internally.

1 → file descriptor for stdout.

0 = stdin

1 = stdout

2 = stderr

"Hello\n" → the data being written.

6 → number of bytes written.

So in short — 1 means stdout in Unix/Linux file descriptor numbers.

If you want, I can show you a quick example of how printf actually ends up calling write(1, ...) internally.


The General Form

A recurrence has the form:

T(n)=a⋅T(bn​)+f(n)

Where:

a = number of subproblems in the recursion

n/b = size of each subproblem (b > 1)

f(n) = cost of dividing the problem + merging the results (non-recursive work)
Case 1 — Recursive work dominates

T(n)=8T(n/2)+O(n2)

a = 8, b = 2 → log₂(8) = 3

f(n) = O(n²) which is smaller than n³ → Case 1

T(n) = Θ(n³)

Case 2 — Balanced work

T(n)=2T(n/2)+O(n)

a = 2, b = 2 → log₂(2) = 1

f(n) = Θ(n¹) → matches → Case 2

T(n) = Θ(n log n)


Case 3 — Non-recursive work dominates
T(n)=2T(n/2)+O(n
2
)
a = 2, b = 2 → log₂(2) = 1

f(n) = O(n²) which is larger than n¹ → Case 3

T(n) = Θ(n²)



Week 1 – Foundations

✅ Goal → Understand what IPC is and practice the simplest mechanisms.

Day 1: Intro to IPC — why we need it, difference between process & thread, isolation.

Day 2: Pipes — parent → child communication (C program).

Day 3: Anonymous pipes with multiple children.

Day 4: Named Pipes (FIFOs) between unrelated processes.

Day 5: Signals — write handler for SIGINT, SIGUSR1.

Day 6: Signal-based notification (e

🔹 1. Basics You Must Be Crystal Clear On

Pipe (unnamed)

Exists only between processes with a parent-child relationship.

Created with pipe(int fd[2]).

fd[0] → read end, fd[1] → write end.

Data flow is unidirectional.

Named Pipe (FIFO)

Created with mkfifo() or mknod().

Exists as a special file in the filesystem.

Can be used by unrelated processes.

Same semantics: one end writes, one end reads.

🔹 2. Common Interview Questions / Tasks

Simple parent → child communication using pipe().
(Parent writes a string, child reads it).

Two-way communication using two pipes (since pipe is unidirectional).
(Parent sends request → Child processes → Child sends back result).

FIFO for unrelated processes

One program writes logs into FIFO.

Another program continuously reads them.

Non-blocking I/O with O_NONBLOCK on pipes.

What happens if you read() from empty pipe?

What happens if you write() to a pipe with no reader?

Select/poll on FIFO

Monitor multiple FIFOs at once (real system case).

🔹 3. Errors You Must Understand

Broken pipe (SIGPIPE): Happens if you write to a pipe with no readers.

Blocking behavior:

read() blocks if empty.

write() blocks if buffer full (until reader consumes).

EOF detection: read() returns 0 when writer closes.

🔹 4. Advanced Practice Problems

Logger System

Create a FIFO /tmp/logger_fifo.

Multiple client processes write log messages.

One server process reads them and writes to a file.

Chat Program

Two FIFOs (fifo1, fifo2).

Process A writes to fifo1, reads from fifo2.

Process B does the opposite.

Pipe + fork + exec

Implement a mini shell: ls | grep txt.

Parent sets up a pipe, forks two children:

Child 1 redirects stdout to pipe write end (dup2).

Child 2 redirects stdin to pipe read end (dup2).



You said:
yes
ChatGPT said:

Perfect! Here’s a diagram comparing simple, forking, and notify so you can visualize how systemd tracks processes:

1. Type = simple
systemd (PID 1)
   │
   └─ service process (ExecStart)


Service runs in foreground.

systemd considers it started immediately.

No fork; systemd tracks the process directly.

2. Type = forking
systemd (PID 1)
   │
   └─ service parent process
         │
         └─ service child process (daemon)


Service forks (daemonizes).

systemd waits for the parent to exit before marking service as started.

Tracks the child process (via PIDFile or re-parenting).

3. Type = notify
systemd (PID 1)
   │
   └─ service process


Service may run in foreground or fork.

systemd waits for READY notification (sd_notify("READY=1")) from the service.

Useful for services that need initialization to complete before systemd marks them ready.

Key Points

simple → immediate start, foreground.

forking → waits for parent exit, tracks daemon child.

notify → waits for explicit readiness signal


suggestion by kernel programming course

Character drivers
Memory management
Synchronization in linux kernel
Linux kernel development model and compilation
Communication with hardware
Interrupt and bottom half



P1: IRQ → timer vs delayed_work

Top-half: simulate IRQ (tasklet or threaded IRQ).

Path A: reschedule with hrtimer; Path B: schedule_delayed_work.

Log context and latency; show why delayed_work is safer for sleep.

P2: char driver with mmap + ring buffer

Producer in a kthread/workqueue, consumer from userspace via mmap.

Protect with seqlock; add poll()/read() using waitqueues.

P3: DMA-style buffer

On x86 laptop, emulate with dma_alloc_coherent (or stub if no device).

Show cache coherency difference vs kmalloc.

P4: SLUB cache

Create kmem_cache for your message structs; benchmark vs kmalloc.

P5: runtime PM demo (platform driver)

Fake MMIO device from DTS (or platform data).

Implement probe/remove, suspend/resume, and pm_runtime_get/put.

MSS is responsible for writing NV items (the AP just forwards the request).


Who creates device nodes?

In Linux, device nodes (like /dev/sda, /dev/ttyUSB0) are just special files that represent hardware.

These are not created manually (except for very old systems).

Instead:

The kernel exposes devices via sysfs (/sys/class, /sys/block, etc.).

The udevd daemon (from systemd-udevd.service) listens for kernel uevents (like add, remove, change) and then:

Creates the corresponding device node in /dev/

Applies rules (naming, permissions, symlinks, scripts, etc.)

👉 So, udevd is the actual worker that creates and manages device nodes.

🔹 2. What problem does udev-trigger solve?

At boot, many devices already exist before udevd even starts (like root disk, keyboard, GPU).

The kernel already has them registered in sysfs, but no events will be sent again just because udevd started late.

If nothing is done, udevd won’t know about them → /dev/ would stay empty.

👉 That’s where systemd-udev-trigger.service comes in.

🔹 3. Role of udev-trigger

When systemd-udev-trigger.service runs:

It walks through /sys/ and looks at all already-present devices.

It emits synthetic add events for each device.

These fake events are sent to udevd, as if the devices were just plugged in.

This way, udevd can:

Recognize all devices that were present before it started.

Create the correct device nodes under /dev/.

Apply udev rules (permissions, ownership, symlinks, scripts).

🔹 4. Example sequence

Kernel boots and registers /sys/class/block/sda (your hard disk).

udevd starts, but it missed the original kernel event.

udev-trigger runs:

Sees /sys/class/block/sda.

Sends a synthetic “add event” for it.

udevd receives this event:

Creates /dev/sda.

Runs rules (maybe creates /dev/disk/by-uuid/...).

🔹 5. Relationship with other services

systemd-udevd.service → runs the daemon that listens and creates device nodes.

systemd-udev-trigger.service → generates fake events so existing devices are recognized.

systemd-udev-settle.service → waits until all queued udev events are handled (useful before mounting disks).

✅ Final clear point:

udev-trigger itself does not create device nodes.

It only triggers recognition of existing devices by simulating "add events".

udevd is the one that actually creates the nodes in /dev/


Bootloader or Linux PIL driver loads modem.mdt.

MDT says:

Load modem.b00 at address X.

Load modem.b01 at address Y.

…

Load modem.b16 at address Z.

All .bXX chunks are stitched together in RAM.

The complete modem firmware image is verified and started.

extern int vfs_create(struct inode *, struct dentry *, umode_t, bool);
1632  extern int vfs_create2(struct vfsmount *, struct inode *, struct dentry *, umode_t, bool);
1633  extern int vfs_mkdir(struct inode *, struct dentry *, umode_t);
1634  extern int vfs_mkdir2(struct vfsmount *, struct inode *, struct dentry *, umode_t);
1635  extern int vfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
1636  extern int vfs_mknod2(struct vfsmount *, struct inode *, struct dentry *, umode_t, dev_t);
1637  extern int vfs_symlink(struct inode *, struct dentry *, const char *);
1638  extern int vfs_symlink2(struct vfsmount *, struct inode *, struct dentry *, const char *);
1639  extern int vfs_link(struct dentry *, struct inode *, struct dentry *, struct inode **);
1640  extern int vfs_link2(struct vfsmount *, struct dentry *, struct inode *, struct dentry *, struct inode **);
1641  extern int vfs_rmdir(struct inode *, struct dentry *);
1642  extern int vfs_rmdir2(struct vfsmount *, struct inode *, struct dentry *);
1643  extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
1644  extern int vfs_unlink2(struct vfsmount *, struct inode *, struct dentry *, struct inode **);
1645  extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);
1646  extern int vfs_rename2(struct vfsmount *, struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);



why kernel has more synchronization like rcu,rw,squential locks but user level we have only spinlock,semaphore
ChatGPT said:

Ah, this is a fundamental kernel vs user-space design question — very common in interviews. Let’s go deep and precise.

1. Kernel context vs user context
Aspect	Kernel	User-space
Execution mode	Runs in privileged mode, handles hardware, interrupts, preemption	Runs in unprivileged mode, cannot directly disable interrupts
Concurrency	SMP systems, interrupts, softirqs, bottom halves, multiple CPUs	Only threads/processes scheduled by OS, no direct interrupts
Critical sections	May need to protect data from preemption, IRQs, bottom halves, other CPUs	Only need to protect from other threads/processes
Latency constraints	Very low-latency, non-blocking often required	Can block safely, OS handles scheduling
2. Why kernel has specialized locks
🔹 Spinlocks

Protect short critical sections.

Can be used in interrupt context, cannot sleep.

🔹 RW locks

Allow multiple readers but single writer.

Useful in kernel because many data structures are read frequently, written rarely.

🔹 RCU (Read-Copy-Update)

Extremely low-overhead read-side lock-free mechanism.

Readers don’t block writers.

Writers defer freeing or updating until all pre-existing readers finish.

Used in hot paths like process tables, routing tables.

🔹 Seqlocks (sequence locks)

Writers increment a sequence number.

Readers can detect if a writer updated data mid-read.

Good for high-read, low-write situations.

3. Why user-space mostly has simpler locks

User threads cannot disable interrupts.

OS scheduler will preempt threads, so most blocking synchronization (mutex, semaphore, condition variables) is enough.

User-space apps rarely need ultra-low-latency non-blocking reads.

Libraries like pthread provide mutexes, semaphores, and read-write locks, but RCU or spinlocks are rarely used in pure user-space apps.

4. Key reason

Kernel deals with multiple CPUs, interrupts, preemption, and hardware, so it needs many specialized synchronization primitives for different scenarios (blocking, non-blocking, read-heavy, IRQ-safe).
User-space deals only with threads scheduled by the OS, so mutexes, semaphores, and pthread RW locks are enough.


fatal signals are a fundamental concept in Linux process management. Let’s break it down clearly.

1. Signals in Linux

Signals are asynchronous notifications sent to a process to indicate events.

Some signals can be caught or ignored, others cannot.

2. Fatal signals

Fatal signals are those that, by default, will terminate the process if not handled.

The kernel sends these when something seriously wrong happens in a process.

Examples include:

Signal	Description
SIGKILL (9)	Immediately kills the process. Cannot be caught, blocked, or ignored.
SIGSEGV (11)	Segmentation fault — invalid memory access.
SIGBUS (7)	Bus error — invalid memory alignment.
SIGFPE (8)	Floating-point exception — divide by zero, overflow.
SIGILL (4)	Illegal instruction.
SIGABRT (6)	Abort from abort() system call.

By default, all these signals terminate the process and may produce a core dump.

3. Key points

Fatal vs non-fatal signals:

Fatal → terminate process if not handled (e.g., SIGSEGV)

Non-fatal → can be caught/ignored (e.g., SIGUSR1, SIGCHLD)

SIGKILL is the only truly uncatchable signal.

Other fatal signals can be caught using a signal handler to attempt cleanup.

4. Why important in kernel/dev

Kernel often sends fatal signals for invalid user-space behavior (e.g., bad memory access).

In device drivers or embedded apps, you must handle signals carefully to avoid process crash.

✅ Interview-style short answer:

“Fatal signals are signals that, by default, terminate the process. Examples include SIGKILL, SIGSEGV, SIGBUS, SIGFPE, SIGILL, and SIGABRT. Some can be caught to attempt cleanup, but SIGKILL cannot.



char *s1 = "hello";
char *s2 = "hello";

if (s1 == s2) printf("Equal\n");
else printf("Not equal\n");
❓What do you think will be printed?

You said:
equal wright


ChatGPT said:
✅ Most likely “Equal” — but with a catch.

Here’s why:

In C, identical string literals may be merged by the compiler (string pooling/constant folding).

So "hello" in both s1 and s2 usually points to the same address in .rodata, making s1 == s2 true.

That’s why on GCC/Clang in release builds, you’ll almost always see “Equal”.

⚠️ But the C standard does not guarantee this.

Some compilers or build flags may disable string literal merging.

In that case, "hello" might be stored twice, and s1 == s2 would be false → prints “Not equal”.

👉 A safer check for string equality is always strcmp(s1, s2) == 0




Debug I2C issues
The section describes the default logging method of the I2C software driver to enable logging the I2C
transfer failures.
Linux
The I2C driver logs are enabled through the kernel dynamic debugging method. Enable
CONFIG_DYNAMIC_DEBUG in <workspace_path_of_LINUX_kernel_image>/sources/
kernel/kernel_platform/kernel/arch/arm64/configs/qcom_defconfig to support the
dynamic debugging of the kernel drivers.
To enable and view the I2C driver logs in the kernel logs (dmesg), run the following commands.
mount -t debugfs none /sys/kernel/debug
echo -n "file i2c-qcom-geni.c +p" > /sys/kernel/debug/dynamic_debug/control
echo -n "file i2c-core-base.c +p" > /sys/kernel/debug/dynamic_debug/control
echo -n "file i2c-dev.c +p" > /sys/kernel/debug/dynamic_debug/control
echo -n "file i2c-mux.c +p" > /sys/kernel/debug/dynamic_debug/control
echo -n "file gpi.c +p" > /sys/kernel/debug/dynamic_debug/control



#include <stdio.h>
#include <stdlib.h>
int main() {
    int *p = malloc(20);  // allocate 20 bytes (not ints!)
    *p = 'A';             // store 65 in p[0]

    printf("%d", *(p+4)); // print the 5th int
    return 0;
}
🔹 What happens
malloc(20) allocates 20 bytes.

On most systems sizeof(int) == 4, so you can safely access only 5 ints (20 / 4 = 5).

Your array effectively is p[0]..p[4].

*p = 'A';

'A' = 65 is written to p[0].

*(p+4) = p[4].

You never assigned a value to p[4].

Its content is indeterminate (garbage).

Reading it is undefined behavior in C.


echo 7 4 1 7 > /proc/sys/kernel


/ # cat /proc/cmdline
noinitrd ro rootwait console=ttyMSM0,115200,n8 no_console_suspend=1 androidboot.hardware=qcom androidboot.console=ttyMSM0 lpm_levels.sleep_disabled=1 service_locator.enable=1 firmware_class.path=/lib/firmware/updates msm_rtb.filter=0x237 rootfstype=ubifs rootflags=bulk_read root=ubi0:rootfs ubi.mtd=38 androidboot.serialno=c493494f androidboot.baseband=msm eipv4= eipv6= ermac= ima_appraise=off evm=fix

rootfs type is UBIfs


void *malloc(size_t size) {
    // align size to word boundary
    size = align(size);

    // search free list for available block
    block = find_free_block(size);

    if (!block) {
        // ask OS for more memory if none available
        block = sbrk(size + overhead);
        if (block == (void*) -1)  // sbrk failure
            return NULL;
    }

    // mark block as used
    mark_block_used(block, size);

    // return pointer to usable memory
    return (void*)(block + 1); // skip metadata
}


void free(void *ptr) {
    if (ptr == NULL) return;

    // Get the block header (stored before user pointer)
    block_header *block = (block_header*)ptr - 1;

    // Mark block as free
    block->is_free = 1;

    // Try to merge with neighboring free blocks
    coalesce(block);

    // Insert into free list so malloc can reuse it
    insert_into_free_list(block);
}

	repo init -u ssh://vgit.lge.com:29430/bmw/linux/manifest -b wave_v015.148.000.high.oem_250805 -m nad-5g.xml -q --reference=/data001/vc.integrator/mirror/wave_v015.148.000.high.oem_250805 --repo-url=ssh://vgit.lge.com:29430/repo.git --no-clone-bundle
	



sh-3.2# cat fsck_result
/dev/mmcblk0p21: recovering journal
Truncating orphaned inode 279 (uid=0, gid=200, mode=0100775, size=0)
Setting free inodes count to 32454 (was 32455)
/dev/mmcblk0p21: clean, 314/32768 files, 31778/131072 blocks
/dev/mmcblk0p22: recovering journal
Setting free inodes count to 32678 (was 32679)
Setting free blocks count to 119845 (was 119848)
/dev/mmcblk0p22: clean, 90/32768 files, 11227/131072 blocks
TIME : 2025-09-20 02:32:24


61366 2025/09/22 15:54:43.426000 138.2251 124 WAVA POW POW 1782 log info verbose 8 [ PowerControlExVariant : 1782 : 1864 ] initNodeWakeupReason() curr wakeup_reason = 5, len = 59



enum POWER_MODE{
    MODE_INIT,
    MODE_SLEEP,
    MODE_LOW_POWER,
    MODE_NAD_ALWAYS_ON,
    MODE_NAD_ALWAYS_ON_DEBUG,
    MODE_NORMAL_OPERATING,
    MODE_MTS,
    MODE_TEMPERATURE_SHUTDOWN,
    MODE_MAX,
};

NAO timer|Wakeup_Reason|wakeup source|newMode=



#define READ_BUF_SIZE	32
#define MAX_BUF		100
#define SYSFS_LAST_RESUME_IRQ_PATH	"/sys/power/pm_wakeup_irq"
#define RESET_REASON_PATH	"/sys/devices/platform/wave-control/wave_sysfs/reset_reason"
#define WAVE_SYSFS_PATH		"/sys/devices/platform/wave-control/wave_sysfs"
#define WAKEUP_REASON_PATH	"/sys/devices/platform/wave-control/wave_sysfs/wakeup_reason"
#define WAVE_SHUTDOWN_PATH	"/sys/module/wave_control/parameters/wave_shutdown"
#define WUP_PATH	"/dev/wup"

/* Wakeup IRQ */
#define NAD2AP_STATUS_IRQ_PATH		"/sys/devices/platform/wave-control/wave_sysfs/nad2ap_status_irq"
#define NAD2AP_ERRFATAL_IRQ_PATH	"/sys/devices/platform/wave-control/wave_sysfs/nad2ap_errfatal_irq"
#define NAD2AP_WAKEUP_IRQ_PATH		"/sys/devices/platform/wave-control/wave_sysfs/nad2ap_wakeup_irq"
#define WAKEUP_BTN_IRQ_PATH		"/sys/devices/platform/wave-control/wave_sysfs/wup_btn_irq"
#define ECALL_BTN_IRQ_PATH		"/sys/devices/platform/wave-control/wave_sysfs/ecall_btn_irq"

/* Wakeup reason */
#define WAKEUP_REASON_UNKNOWN		0
#define WAKEUP_REASON_NAD   		1
#define WAKEUP_REASON_A35   		2
#define WAKEUP_REASON_M4    		3
#define WAKEUP_REASON_BTN_IRQ		4
#define WAKEUP_REASON_ECALL_BTN_IRQ	5

/* Reset reason */
#define	SC_PM_RESET_REASON_POR 0 /* Power on reset */
#define SC_PM_RESET_REASON_JTAG 1 /* JTAG reset */
#define	SC_PM_RESET_REASON_SW 2 /* Software reset */
#define	SC_PM_RESET_REASON_WDOG 3 /* Partition Watchdog reset */
#define	SC_PM_RESET_REASON_LOCKUP 4 /* SCU lockup reset */
#define SC_PM_RESET_REASON_SNVS 5 /* SNVS reset */
#define	SC_PM_RESET_REASON_TEMP 6 /* Temp panic reset */
#define SC_PM_RESET_REASON_MSI 7 /* MSI reset */
#define SC_PM_RESET_REASON_UECC 8 /* ECC reset */
#define SC_PM_RESET_REASON_SCFW_WDOG 9 /* SCFW watchdog reset */
#define SC_PM_RESET_REASON_ROM_WDOG 10 /* SCU ROM watchdog reset */
#define SC_PM_RESET_REASON_SECO 11 /* SECO reset */
#define SC_PM_RESET_REASON_SCFW_FAULT 12 /* SCFW fault reset */
#define SC_PM_RESET_REASON_A35_SWR 13 /* Software reset by A35 */
#define SC_PM_RESET_REASON_M4_SWR 14 /* Software reset by M4 */
#define SC_PM_RESET_REASON_A35_WDOG 15 /* A35 Partition watchdog reset */
#define SC_PM_RESET_REASON_M4_WDOG 16 /* M4 Partition watchdog reset */
#define SC_PM_RESET_REASON_EXT_WDOG 17 /* Ext. watchdog reset */
#define SC_PM_RESET_REASON_SCFW_COMMON 18 /* SCFW Common fault handler */
#define SC_PM_RESET_REASON_SCFW_CPU 19 /* Cortex-M ECC or lockup error */
#define SC_PM_RESET_REASON_SCFW_EXIT 20 /* SCFW Exit */
#define SC_PM_RESET_REASON_SCFW_DDR_RET 21 /* DDR retention request without configuration */
#define SC_PM_RESET_REASON_SCFW_BAD_CONTAINER 22 /* Bad boot container, invalid partitions,images */
#define SC_PM_RESET_REASON_SCFW_UNKOWN 23 /* SCFW unkown fault */
#define SC_PM_RESET_REASON_SUSPEND_FAIL 24 /* Suspend fail reset */
#define SC_PM_RESET_REASON_EIS 25 /* Software reset by EIS */
#define SC_PM_RESET_ECALL 26 /* Force reset by eCall btn while ongoing system shutdown */
#define SC_PM_RESET_REASON_SCU_PM_ERR 27 /* SCU Power Mode Error */


444 2025/09/22 17:14:35.350000 2.6241 171 WAVA SYS SYSL 1536 log error verbose 1 <11>Sep 20 02:32:25 kernel: [    1.461132] [WAVE CTL][nad2ap_wakeup_func:192] NAD2AP_WAKEUP interrupt dectected


/sys/kernel/debug # cat wakeup_sources
name            active_count    event_count     wakeup_count    expire_count    active_since    total_time      max_time        last_change     prevent_suspend_time
power_manager_daemon    1               1               0               0               381264          381264          381264          33100           0
msm_wmapro      0               0               0               0               0               0               0               0               0
msm_wma         0               0               0               0               0               0               0               0               0
msm_qcelp       0               0               0               0               0               0               0               0               0
msm_multi_aac   0               0               0               0               0               0               0               0               0
msm_mp3         0               0               0               0               0               0               0               0               0
msm_g711mlaw    0               0               0               0               0               0               0               0               0
msm_g711alaw    0               0               0               0               0               0               0               0               0
msm_evrc        0               0               0               0               0               0               0               0               0
msm_ape         0               0               0               0               0               0               0               0               0
msm_amrwbplus   0               0               0               0               0               0               0               0               0
msm_amrwb       0               0               0               0               0               0               0               0               0
msm_amrnb       0               0               0               0               0               0               0               0               0
msm_alac        0               0               0               0               0               0               0               0               0
msm_aac         0               0               0               0               0               0               0               0               0
spkr-prot       0               0               0               0               0               0               0               0               0
IPA_CLIENT_APPS_WAN_CONS        0               0               0               0               0               0               0               0               0
qrtr_ws         15707           15707           0               0               0               66              0               414306          62
qrtr_ws         2111            2111            0               0               0               9               0               414210          8
MODEM (MHI)     0               0               0               0               0               0               0               0               0
MHI             0               0               0               0               0               0               0               0               0
IPA_CLIENT_MEMCPY_DMA_ASYNC_CONS        24              24              0               0               375235          393987          375235          39129           381577
IPA_CLIENT_MEMCPY_DMA_SYNC_CONS 0               0               0               0               0               0               0               0               0
rmnet_ipa%d     0               0               0               0               0               0               0               0               0
TETH MODEM      0               0               0               0               0               0               0               0               0
EMB MODEM       0               0               0               0               0               0               0               0               0
IPA_CLIENT_APPS_LAN_CONS        1               1               0               0               0               151             151             2250            0
8a00000.ssusb   1               1               0               0               413045          413045          413045          1319            381587
40002000.qcom,pcie      1               1               0               0               413023          413023          413023          1341            381587
ssr(modem)      0               0               0               0               0               0               0               0               0
pil-modem       1               1               0               0               0               7116            7116            15250           0
IPA_WS          12458           12458           0               0               0               21741           47              414313          20359
200f000.qcom,spmi:qcom,pmd9650@0:qcom,pmd-vbus-det@d00  0               0               0               0               0               0               0               0               0
alarmtimer      0               0               0               0               0               0               0               0               0
200f000.qcom,spmi:qcom,pmd9650@0:qcom,pmd9650_rtc       0               0               0               0               0               0               0               0               0
smp2p           3               3               0               0               0               0               0               15511           0
87000.mhi_dev   1               1               0               0               414137          414137          414137          227             381587
200f000.qcom,spmi:qcom,pmd9650@0:qcom,power-on@800      0               0               0               0               0               0               0               0               0
autosleep       1               1               0               0               0               0               0               32777           0
deleted         0               0               0               0               0               0               0               0               0



/sys/kernel/debug # cat wakeup_sources
name            active_count    event_count     wakeup_count    expire_count    active_since    total_time      max_time        last_change     prevent_suspend_time
power_manager_daemon    1               1               0               0               381264          381264          381264          33100           0
msm_wmapro      0               0               0               0               0               0               0               0               0
msm_wma         0               0               0               0               0               0               0               0               0
msm_qcelp       0               0               0               0               0               0               0               0               0
msm_multi_aac   0               0               0               0               0               0               0               0               0
msm_mp3         0               0               0               0               0               0               0               0               0
msm_g711mlaw    0               0               0               0               0               0               0               0               0
msm_g711alaw    0               0               0               0               0               0               0               0               0
msm_evrc        0               0               0               0               0               0               0               0               0
msm_ape         0               0               0               0               0               0               0               0               0
msm_amrwbplus   0               0               0               0               0               0               0               0               0
msm_amrwb       0               0               0               0               0               0               0               0               0
msm_amrnb       0               0               0               0               0               0               0               0               0
msm_alac        0               0               0               0               0               0               0               0               0
msm_aac         0               0               0               0               0               0               0               0               0
spkr-prot       0               0               0               0               0               0               0               0               0
IPA_CLIENT_APPS_WAN_CONS        0               0               0               0               0               0               0               0               0
qrtr_ws         15707           15707           0               0               0               66              0               414306          62
qrtr_ws         2111            2111            0               0               0               9               0               414210          8
MODEM (MHI)     0               0               0               0               0               0               0               0               0
MHI             0               0               0               0               0               0               0               0               0
IPA_CLIENT_MEMCPY_DMA_ASYNC_CONS        24              24              0               0               375235          393987          375235          39129           381577
IPA_CLIENT_MEMCPY_DMA_SYNC_CONS 0               0               0               0               0               0               0               0               0
rmnet_ipa%d     0               0               0               0               0               0               0               0               0
TETH MODEM      0               0               0               0               0               0               0               0               0
EMB MODEM       0               0               0               0               0               0               0               0               0
IPA_CLIENT_APPS_LAN_CONS        1               1               0               0               0               151             151             2250            0
8a00000.ssusb   1               1               0               0               413045          413045          413045          1319            381587
40002000.qcom,pcie      1               1               0               0               413023          413023          413023          1341            381587
ssr(modem)      0               0               0               0               0               0               0               0               0
pil-modem       1               1               0               0               0               7116            7116            15250           0
IPA_WS          12458           12458           0               0               0               21741           47              414313          20359
200f000.qcom,spmi:qcom,pmd9650@0:qcom,pmd-vbus-det@d00  0               0               0               0               0               0               0               0               0
alarmtimer      0               0               0               0               0               0               0               0               0
200f000.qcom,spmi:qcom,pmd9650@0:qcom,pmd9650_rtc       0               0               0               0               0               0               0               0               0
smp2p           3               3               0               0               0               0               0               15511           0
87000.mhi_dev   1               1               0               0               414137          414137          414137          227             381587
200f000.qcom,spmi:qcom,pmd9650@0:qcom,power-on@800      0               0               0               0               0               0               0               0               0
autosleep       1               1               0               0               0               0               0               32777           0
deleted         0               0               0               0               0               0               0               0               0
/sys/kernel/debug #


 wave low qmi issue:
 
 CR#4289900--DTSI Change
CR#4289903--IPA Driver change

this are the changes 
https://vgit.lge.com/na/c/nad/qct/mdm9650/apps_proc/+/1543285

ipa can be used in mhi mode
ChatGPT said:

Yes 👍

IPA (IP Accelerator) can be used in MHI mode, depending on the modem integration. Let me break it down for you:

🔹 What is IPA?

IPA (IP Accelerator) is a hardware/software block from Qualcomm.

It accelerates packet processing, filtering, routing, and offloading tasks from the AP (Application Processor) to save CPU cycles and power.

It typically sits between the modem (data path) and the host (Linux networking stack).

🔹 What is MHI?

MHI (Modem Host Interface) is a transport protocol that allows the host AP (Linux/Android) to communicate with the modem over PCIe.

It defines channels (control/data), event rings, and transfer rings for efficient communication.

MHI provides a generic way to send/receive data to the modem.

🔹 IPA in MHI mode

Normally, IPA can be used in two ways:

Embedded Mode – IPA sits inside the modem (handles networking inside modem itself).

MHI Mode – IPA driver in the AP uses MHI channels to exchange packets with the modem over PCIe.

In this case, IPA packets (QMI, data traffic) flow through MHI channels.

Device tree usually configures it like this:

&ipa_hw {
    qcom,use-ipa-in-mhi-mode;
    qcom,mhi-event-ring-id-limits = <10 16>; /* start and end event ring IDs */
};


This tells the kernel IPA driver that instead of using direct modem-side IPA resources, it should use MHI channels/event rings to interact with the modem.

🔹 Why use IPA in MHI mode?

Some platforms don’t expose IPA directly to the AP. Instead, they only expose MHI → AP.

IPA still accelerates data, but the AP accesses it through MHI transport.

This improves:

Data throughput (avoiding CPU bottlenecks)

Power efficiency

Unified control via MHI

✅ So yes, IPA can be used in MHI mode — it basically means the IPA data/control path is tunneled over MHI PCIe channels instead of a direct IPA hardware bus.

Do you want me to also explain how the event ring limits (10–16) tie into this configuration (why those numbers matter)?

You said:
if not mhi mode what can it use
ChatGPT said:

Good question 👌

If IPA is not used in MHI mode, then it usually works in its native integration modes, depending on how the SoC/modem is designed. Let me break it down:

🔹 Modes when not in MHI mode

Embedded IPA (Direct Modem Mode)

IPA sits inside the modem subsystem (like modem_proc).

The modem’s own software (QMI, QMAP, etc.) directly programs and uses IPA.

The AP (Application Processor, Linux side) just sees network interfaces exposed by the modem (like rmnet_data0, wwan0).

AP doesn’t have direct control over IPA; it just exchanges packets via shared memory or a transport (e.g., BAM DMA).

BAM (Bus Access Manager) / GSI (Generic Software Interface) Mode

IPA connects directly to the AP using BAM DMA channels (older Qualcomm chips) or GSI DMA engines (newer).

In this case, the AP kernel IPA driver talks directly to the IPA hardware registers via memory-mapped IO.

Data between AP and modem flows through QMI/IPA pipes (not through MHI).

PCIe Direct IPA (without MHI)

On some platforms, IPA is exposed directly over PCIe without abstracting it with MHI.

AP driver talks directly to IPA hardware blocks over PCIe BAR regions.

🔹 Summary

MHI mode → IPA is accessed through MHI transport protocol (common for newer PCIe-based modems).

Non-MHI mode → IPA may be accessed via:

Shared memory + BAM/GSI DMA,

Direct AP ↔ IPA hardware mapping, or

Embedded in modem (modem-only controlled IPA).

👉 So, when you don’t see qcom,use-ipa-in-mhi-mode; in device tree, chances are the SoC is using BAM/GSI mode or direct modem-embedded IPA mode.

Do you want me to draw you a flow diagram of data path for MHI mode vs. non-MHI mode? That way it will be crystal clear.

You said:
ipa will there in modem side and ap and cp communicate through pci and packetsthrough mhi
ChatGPT said:

Exactly 👍 you’ve got the picture right. Let me refine it a bit more so it’s super clear:

📌 Where IPA lives

IPA hardware (IP Accelerator) is physically inside the modem (CP) subsystem.

But drivers for IPA exist on both AP and CP sides, because AP still needs to configure some pipes, offloads, and network interfaces.

📌 How AP ↔ CP communication happens

Transport layer → PCIe

AP and CP are connected via PCIe.

This provides the physical transport.

Control / Channel abstraction → MHI (Modem Host Interface)

On top of PCIe, MHI creates channels (control channels, data channels).

AP driver uses these MHI channels to talk to the modem.

Data path → IPA

Actual packet flow (IP packets for rmnet/wwan interfaces) is accelerated by IPA inside CP.

AP sees rmnet_dataX network devices.

Packets go: AP kernel ↔ MHI channel ↔ IPA ↔ Modem stack.

📌 Modes

MHI mode enabled:

AP driver uses MHI channels → Modem’s IPA → Internet.

Non-MHI (legacy):

AP could use BAM/GSI DMA pipes directly mapped to IPA (older SoCs, e.g., MSM8996).

So your line is right:

IPA will be there in modem side, and AP and CP communicate through PCIe, and packets flow through MHI channels. ✅

Do you want me to also explain why Qualcomm added MHI on top of PCIe instead of letting AP directly program IPA over PCIe?

You said:
so what is pci do if communication happens in mhi
ChatGPT said:

Good question 👍 — you’re thinking about the layering right. Let’s break it down step by step:

📌 PCIe’s role

PCIe is just the physical transport bus between AP ↔ CP.

Think of it like a high-speed highway:

It only knows how to send packets of bytes between endpoints.

It doesn’t know anything about modem control, channels, or network packets.

Without something on top, AP would just see a PCI device with BARs, MMIO regions, and raw DMA.

📌 MHI’s role

MHI (Modem Host Interface) is a protocol layered on top of PCIe.

It defines:

Channels (control/data separation).

Doorbells (notifications/events).

Descriptors for buffers.

State machines (RESET, READY, etc.).

So, MHI organizes raw PCIe transfers into structured communication channels.
Example:

Channel 4 → AT commands

Channel 10 → QMI control

Channel 100+ → IP data via IPA

📌 IPA’s role

IPA sits inside the modem, connected to the modem CPU and radio stack.

When MHI transfers IP packets over PCIe, IPA accelerates those packets:

Offloads checksums

Routing/filtering

Zero-copy transfers to modem stack

High throughput for AP ↔ Internet traffic

✅ So the chain looks like this:

[AP Kernel] 
   |
   v
MHI driver (channels, rings)
   |
   v
PCIe bus (physical transport)
   |
   v
Modem PCIe endpoint
   |
   v
MHI core in CP + IPA accelerator
   |
   v
[Modem stack / Network]


👉 In short:

PCIe = highway (raw transport)

MHI = traffic rules & lanes

IPA = turbo engine that accelerates packets once inside modem

Do you want me to also draw an analogy with USB (where PCIe = wires, MHI = USB protocol, IPA = like a NIC hardware offload)? It may make it even clearer.

You said:
It only knows how to send packets of bytes between endpoints. means
ChatGPT said:

Great catch 👌 Let me make that line very clear.

When I said “PCIe only knows how to send packets of bytes between endpoints”, I meant:

📌 PCIe is just a transport protocol

PCIe defines packets (TLPs = Transaction Layer Packets).

These packets carry things like:

Read from address X in device memory

Write this buffer to address Y

That’s all. It doesn’t know what those bytes mean.

Example:

AP writes 0x01 0x02 0x03 0x04 → PCIe sends those 4 bytes to CP BAR address.

PCIe doesn’t know if that’s:

a modem command,

an IP packet, or

just garbage.

📌 Contrast with MHI

MHI interprets those bytes and gives them meaning:

“Oh, these bytes belong to Channel 10 → QMI control”

“These bytes → Channel 100 → IP packet for IPA”

So PCIe = postman 📦 delivering envelopes, doesn’t care what’s inside.
MHI = office clerk 🧑‍💼 who reads the label on each envelope and puts it in the correct inbox.
IPA = specialist 📡 who processes IP packets quickly once they reach the modem side.

👉 In short:
When I say “PCIe only knows how to send packets of bytes between endpoints”, I mean it just moves raw data, no structure, no protocol semantics.
The higher-level protocols (MHI, QMI, IP) decide what the data means


message passing have direct communication and indirect communication synchronous,asynchronus,automatic or explicit
ChatGPT said:

Let’s carefully break this down. In message passing for inter-process communication (IPC), we have multiple classifications:

1. Direct vs Indirect Communication

Direct communication:

Processes must explicitly name the recipient/sender.

Example: send(P, message) or receive(Q, message) where P and Q are process names.

Indirect communication:

Processes communicate via mailboxes or ports.

Processes do not need to know each other’s identity.

Example: send(mailbox1, message) and receive(mailbox1, message)

2. Synchronization: Synchronous vs Asynchronous

Synchronous (blocking):

Sending or receiving a message blocks the process until the other side is ready.

Guarantees immediate delivery acknowledgment.

Example: send() waits until receive() is ready.

Asynchronous (non-blocking):

The sender continues execution without waiting for the receiver.

The message is queued in a mailbox or buffer.

3. Communication style: Automatic vs Explicit

This is less standard but sometimes described in textbooks:

Automatic (implicit):

The system automatically delivers messages, schedules processes, or handles buffering.

Processes do not control delivery.

Explicit:

The sender or receiver explicitly controls message delivery or reception.

Examples: explicit send()/receive() calls in code.

✅ Summary Table:

Aspect	Types	Description
Communication	Direct	Process names are used
	Indirect	Mailboxes/ports are used
Synchronization	Synchronous	Blocking until delivered/received
	Asynchronous	Non-blocking; continues execution
Control	Automatic	System handles delivery
	Explicit	Process explicitly calls send/receive
	
	
	mailbox is can be  created process or os
ChatGPT said:

A mailbox in message passing IPC can be created either by the OS or by processes, depending on the system design:

1. OS-created mailboxes

The operating system provides predefined mailboxes or APIs to create them.

The OS manages:

Buffering

Access control

Scheduling of messages

Example: msgget() in System V IPC or mq_open() in POSIX message queues.

Advantage: Processes don’t need to manage memory or synchronization themselves.

2. Process-created mailboxes

A process can create a private mailbox in its own memory (or shared memory) and expose it to other processes.

Usually, the OS still enforces access control if multiple processes need to communicate.

Example: A server process creates a queue and client processes send messages to it.

💡 Rule of thumb:

If the mailbox is used for inter-process communication across multiple processes, it is usually OS-managed.

If it is within a single process or a tightly coupled group, a process can create it manually.



each mailbox has unique interger id
ChatGPT said:

Yes ✅, in most operating systems that provide mailboxes or message queues, each mailbox is identified by a unique integer ID.

Here’s how it works:

1. System V IPC (Message Queues)

When you create a mailbox using msgget(key, flags), the OS returns an integer ID called the message queue ID.

This ID is used in all further operations on that mailbox:

msgsnd(msgid, ...) → send message

msgrcv(msgid, ...) → receive message

The OS ensures uniqueness of IDs system-wide.

2. POSIX Message Queues

POSIX queues are usually named strings (e.g., /queue1), but internally the OS can assign an integer handle or descriptor when you open the queue with mq_open().

This integer descriptor is used to perform read/write operations.

3. Why integer IDs?

Fast access: integers are easier for the kernel to index than strings.

Uniqueness: avoids confusion between mailboxes.

Security/permissions: OS can map IDs to process permissions

Here we can see -3 error when client send the request to modem, which is time out error, usually this time out error will be return if there is no response from modem with in specified time. or if there is any problem in the QRTR side to send the request to modem , but you said other services requests are working normally so there won't be any QRTR problem here



Line 16533: 16532 2025/09/22 12:57:25.034430 202.0654 94 WAVA RIL RILD 15951 log info verbose 1 [qcrilNrd][lge_oemhook_ntc_bsp.cpp:1390][qcrilhook_lge_ntc_nad_alive_status](tid:15969) [LGE_RIL] qmi_transport_error[-3], result[0], error[0x0]


Line 16700: 16699 2025/09/22 12:57:27.032743 204.0698 98 WAVA RIL RILD 15951 log info verbose 1 [qcrilNrd][lge_oemhook_ntc_bsp.cpp:1390][qcrilhook_lge_ntc_nad_alive_status](tid:15969) [LGE_RIL] qmi_transport_error[-3], result[0], error[0x0]



So to further check on this issue we need below things.

1)Looks this NTC is your own service id, what is the service defined for this ?
QMI_FW enabled logs
in your code check for file qmi_fw_debug.h if it is present in multiple paths please make below changes in call paths.
--- a/inc/qmi_fw_debug.h
+++ b/inc/qmi_fw_debug.h
@@ -17,106 +17,33 @@
#ifdef __cplusplus
extern "C" {
#endif
-
+#define QMI_FW_SYSLOG
#define SMEM_LOG_EVENT( event, data1, data2, data3 ) \
do { } while(0)

#define SMEM_LOG_EVENT6(identifier, data1, data2, data3, data4, data5, data6) \
do { } while(0)

-#if defined(QMI_FW_ADB_LOG) || defined(QMI_ANDROID_LOGGING_LE)
-#define LOG_TAG "QMI_FW"
-
-#ifdef QMI_ANDROID_LOGGING_LE
-#include <cutils/log.h>
-#else
-#include <utils/Log.h>
-#endif
-
-#ifdef QMI_CCI_ANDROID
-extern unsigned int qmi_cci_debug_level;
-#define QMI_CCI_LOGI(x...) do { \
- if(qmi_cci_debug_level <= ANDROID_LOG_INFO) \
- SLOGI("QCCI: "x); \
-} while(0)
-#define QMI_CCI_LOGD(x...) do { \
- if(qmi_cci_debug_level <= ANDROID_LOG_DEBUG) \
- SLOGD("QCCI: "x); \
-} while(0)
-#else
-#define QMI_CCI_LOGI(x...)
-#define QMI_CCI_LOGD(x...)
-#endif
-
-#ifdef QMI_CSI_ANDROID
-extern unsigned int qmi_csi_debug_level;
-#define QMI_CSI_LOGI(x...) do { \
- if(qmi_csi_debug_level <= ANDROID_LOG_INFO) \
- SLOGI("QCSI: "x); \
-} while(0)
-#define QMI_CSI_LOGD(x...) do { \
- if(qmi_csi_debug_level <= ANDROID_LOG_DEBUG) \
- SLOGD("QCSI: "x); \
-} while(0)
-#else
-#define QMI_CSI_LOGI(x...)
-#define QMI_CSI_LOGD(x...)
-#end

if
-
-#define QMI_FW_LOGE(x...) ALOGE(x);
-
-#elif defined(QMI_FW_SYSLOG)
#include <syslog.h>

extern unsigned int qmi_cci_debug_level;
extern unsigned int qmi_csi_debug_level;
#define QMI_CCI_LOGI(x...) do { \
- if(qmi_cci_debug_level >= LOG_INFO) \
- syslog(LOG_INFO, "QMI_FW: QCCI: "x); \
+ syslog(LOG_DEBUG, "QMI_FW: QCCI: "x); \
} while(0)
#define QMI_CSI_LOGI(x...) do { \
- if(qmi_csi_debug_level >= LOG_INFO) \
- syslog(LOG_INFO, "QMI_FW: QCSI: "x); \
+ syslog(LOG_DEBUG, "QMI_FW: QCSI: "x); \
} while(0)

#define QMI_CCI_LOGD(x...) do { \
- if(qmi_cci_debug_level >= LOG_DEBUG) \
syslog(LOG_DEBUG, "QMI_FW: QCCI: "x); \
} while(0)
#define QMI_CSI_LOGD(x...) do { \
- if(qmi_csi_debug_level >= LOG_DEBUG) \
syslog(LOG_DEBUG, "QMI_FW: QCSI: "x); \
} while(0)

#define QMI_FW_LOGE(x...) syslog(LOG_ERR, x)

-#else
-#define QMI_CCI_LOGI(x...) do { \
- fprintf(stdout, "%s(%d) ", __FUNCTION__, __LINE__); \
- fprintf(stdout, ##x); \
- } while(0)
-
-#define QMI_CCI_LOGD(x...) do { \
- fprintf(stdout, "%s(%d) ", __FUNCTION__, __LINE__); \
- fprintf(stdout, ##x); \
- } while(0)
-
-#define QMI_CSI_LOGI(x...) do { \
- fprintf(stdout, "%s(%d) ", __FUNCTION__, __LINE__); \
- fprintf(stdout, ##x); \
- } while(0)
-
-#define QMI_CSI_LOGD(x...) do { \
- fprintf(stdout, "%s(%d) ", __FUNCTION__, __LINE__); \
- fprintf(stdout, ##x); \
- } while(0)
-
-#define QMI_FW_LOGE(x...) do { \
- fprintf(stderr, "%s(%d) ", __FUNCTION__, __LINE__); \
- fprintf(stderr, ##x); \
- } while(0)
-#endif
-

2)crash dump when timeout is repeatedly seen.
increase the qrtr page count for safe side to avoid overriding of logs.
kernel/net/qrtr/qrtr.c
#define QRTR_LOG_PAGE_CNT 4--------------150


3. How QRTR, MHI, and PCI relate
Layer	Function	Example
Application Layer	QMI service request	qcrilhook_lge_ntc_nad_alive_status()
Transport Layer	QRTR routes requests to correct service ID	Service discovery + routing
Protocol/Link Layer	MHI handles high-speed data transfer over PCIe	Packet framing, interrupts
Physical Layer	PCIe bus	Actual bytes sent between AP and CP

Flow:

Client (AP side)
    ↓
QRTR (routes to service)
    ↓
MHI (framing, interrupts, queue management)
    ↓
PCIe bus (physical transport)
    ↓
Modem (CP)


Key point:

QRTR = logical routing of messages

MHI/PCI = physical transport of packets


unamed pipes also unidirectional we use two file descriptors for bidirectional
ChatGPT said:

Exactly! You’ve got it. Let me summarize clearly:

Unnamed Pipes (|)

Unidirectional by default

Data flows in one direction: parent → child or child → parent.

Two file descriptors

When you create a pipe using pipe(fd), you get two file descriptors:

fd[0] → read end

fd[1] → write end

Bidirectional communication

A single unnamed pipe cannot be bidirectional.

To achieve two-way communication between processes, you need two pipes:

Pipe1: parent → child

Pipe2: child → parent

Parent-child restriction

Unnamed pipes are usually used between related processes, e.g., parent and child after fork().

Cannot be directly used by unrelated processes because there’s no filesystem entry (unlike named pipes/FIFOs).

✅ Summary:

Unnamed pipes = unidirectional, parent-child only.

Named pipes (FIFOs) = unidirectional by default, can be used by any process that knows the name.

Bidirectional communication in both cases = use two pipes (two FDs or two FIFOs)



why volatile variable is not used in mutual exclusion,synchronization ? my answer: it will be shared multiple threads any thread can change it . so we cant lock every where and if any thread changes it it should visible to another cpu
ChatGPT said:

You’re thinking in the right direction 👏 — and your reasoning is partly correct. Let’s refine it with a deeper, system-level explanation (the kind Qualcomm or kernel interviews expect):

🧩 Your answer summary

“Volatile variables are shared among multiple threads, any thread can change it, so we can’t lock everywhere. And if any thread changes it, it should be visible to another CPU.”

Good — you’re hinting at visibility and synchronization, but the key distinction is what volatile actually guarantees (and what it doesn’t).

✅ What volatile actually does

It tells the compiler not to optimize or cache the variable in a register.

Every read/write to that variable must actually happen in memory, not in a CPU register.

That’s it.
It has no atomicity, no ordering, and no mutual exclusion guarantees.

🚫 Why volatile is not enough for synchronization

Let’s take this example:

volatile int flag = 0;

void *thread1(void *arg) {
    flag = 1;   // signal done
}

void *thread2(void *arg) {
    while (flag == 0);  // wait
    printf("flag set!\n");
}


You might think this synchronizes two threads — but it doesn’t reliably work on multicore CPUs.

⚙️ Why it fails (deep reason)

CPU Caches:
Each core may have its own cache. One thread’s write (flag=1) might stay in its cache and not be visible to another CPU immediately.
volatile doesn’t flush or invalidate caches.

Instruction Reordering:
Compilers and CPUs can reorder memory operations around volatile accesses.
→ Thread 2 might see flag=1 before Thread 1 finishes writing some shared data.

Atomicity missing:
If two threads modify a variable (like increment), the operation isn’t atomic:

volatile int counter;
counter++;  // not atomic: read-modify-write


Multiple threads can corrupt the value.

🔒 Correct approach: Use synchronization primitives

Use mutexes, spinlocks, semaphores, or atomic operations.

Or use memory barriers (smp_mb, smp_rmb, smp_wmb) in the kernel.

Example:

atomic_t flag = ATOMIC_INIT(0);
atomic_set(&flag, 1);
if (atomic_read(&flag))
    ...


or for kernel-level:

spin_lock(&lock);
critical_section();
spin_unlock(&lock);


These guarantee:

Atomicity

Memory ordering

Visibility across CPUs

🧠 Summary answer for interview

“volatile only prevents compiler optimizations — it doesn’t guarantee atomic access or memory ordering.
For synchronization or mutual exclusion, we need locks, atomics, or memory barriers because volatile doesn’t ensure visibility or consistency between cores.”



WAVE:80866

Call Stacks
=========================
-000|abort()
-001|do_crash_dump()
-002|service_resource_exit()
-003|aop_fsm_process_event()
-004|aop_services_process()
-005|aop_services_main_loop()
-006|rex_task_preamble()
----|end of frame



Registers
=========================
r0          80000000  r10         000E4C78  basepri     00000000
r1          80000000  r11         00000001  control     00000002
r2          00000001  r12         C0000000
r3          0000001C  r14         0000C489
r4          000E36D8  msp         000E7F68
r5          FFFFFFFF  psp         000E6988
r6          000E36C0  pc          00002C2D
r7          000E12E0  xpsr        60000000
r8          00000080  primask     00000000
r9          00010B44  faultask    00000001



Fault_details
=========================
SystemHandlerCtrlAndState:                0x00070000 |      458752
ConfigurableFaultStatus:                         0x0
HardFaultStatus:                                 0x0
DebugFaultStatus:                                0x0
MemManageAddress:                         0xE000ED34 |  3758157108
BusFaultAddress:                          0xE000ED38 |  3758157112
AuxFaultStatus:                                  0x0
ChatGPT said:

Good — this is a crash dump from the AOP (Always-On Processor), and we can interpret what’s happening here.

Let’s decode it step by step 👇

🧩 1. Call Stack Meaning
-000 | abort()
-001 | do_crash_dump()
-002 | service_resource_exit()
-003 | aop_fsm_process_event()
-004 | aop_services_process()
-005 | aop_services_main_loop()
-006 | rex_task_preamble()


✅ Interpretation:

The AOP task crashed (called abort()).

Before aborting, it went through do_crash_dump(), which is just logging the crash.

The crash happened while processing a resource/service event inside the AOP FSM (finite state machine) — likely a resource transition or dependency failure (for example, a regulator or clock).

The function service_resource_exit() shows it was probably de-initializing or disabling a resource when something went wrong (e.g., invalid pointer or corrupted state).

⚙️ 2. Register Summary
r0  = 0x80000000
r1  = 0x80000000
r2  = 0x00000001
r3  = 0x0000001C
r5  = 0xFFFFFFFF
pc  = 0x00002C2D
xpsr= 0x60000000


✅ Interpretation:

r0/r1 both 0x80000000 → suspicious value (invalid pointer or sentinel constant)

r5 = 0xFFFFFFFF → often a corrupted variable or uninitialized data

pc = 0x2C2D → program counter (where the crash occurred)

xpsr = 0x60000000 → normal thread mode, no fault bits set here

So, most likely this was a software assert / abort, not a hardware exception like bus fault or memory fault.

🧠 3. Fault Registers
HardFaultStatus: 0x0
MemManageAddress: 0xE000ED34
BusFaultAddress:  0xE000ED38


✅ Interpretation:

All fault status registers are 0, so no hardware memory fault or access violation.

That confirms — it’s a deliberate software abort, possibly triggered due to failed internal check or bad state.

🧾 4. Likely Root Cause

The crash in aop_fsm_process_event() and service_resource_exit() indicates:

A resource (e.g., regulator, clock, voltage rail) was being disabled or released.

Some invalid state or resource reference occurred (r0/r1 = 0x80000000).

AOP then called abort() to stop execution and trigger dump.

It’s typically seen when:

AOP receives inconsistent requests from the modem (e.g., after modem restart).

Memory corruption or double-free in AOP service resource handling.

A missed dependency (trying to disable a service that wasn’t initialized).

🧩 5. What You Can Check Next

To dig deeper:

Cross-check timestamp — does this crash align with your RIL timeout (qmi_transport_error[-3])?

If yes → modem might not be responding because AOP crashed (AOP controls power/clock to modem).

Check AOP logs (aop.log or pmic_arb.log) — for events before this crash.

Check QRTR / MHI logs — see if modem link reset occurred after AOP crash.

Would you like me to show how to map the PC (0x2C2D) to the function name using your AOP ELF symbol table (for example, aop.elf)?
That can tell exactly where the crash occurred.

You said:
Core Summary
Image information
=========================
QC_IMAGE_VERSION_STRING=MPSS.HI.3.2.c1-00163-SDX55_GENAUTO_PACK-1
IMAGE_VARIANT_STRING=sdx55.genauto.prodQ
OEM_IMAGE_VERSION_STRING=XN23XA28.2025-09-03.17:40:27
OEM_IMAGE_UUID_STRING=Q_SENTINEL_{C0AA3149-ADE3-4859-9092-BA8C5A1485A6}_20250903_1740



Coredump
=========================
lfw_common_cxn_mgr.c:264   Assertion ((array_ptr->sf_info[cxn_id].proc_orders_done == array_ptr->sf_info[cxn_id].proc_orders_pend) || (array_ptr->sf_info[cxn_id].proc_orders_done == 0)) failed


Call Stacks
=========================
-000|:0xC08F47AC qurt_exception_raise_nonfatal()
-001|:0xD9B99980 fws_error_ipc()
-002|:0xD802512C fws_ipc_send()
-003|:0xD8892748 fw_diag_fatal_setup()
-004|:0xD886172C __fw_lte_s__867894996()
-005|:0xD8860D8C __fw_lte_s__391254659()
-006|:0xC0DB7724 qurt_trampoline()
-007|:0xC0DB7708 qurt_trampoline()
----|end of frame




QuRT Cause Code Details
=========================
Cause      0x0000000C  Application called qurt_fatal_exit()
Cause2     0x00000000  Undefined, not to use for debugging



SSR Details
=========================
SSR : 0x019F0027 Cause : 0x27  Trap



Registers
=========================
PC =      0x00000000
LR =      0x00000000
BADVA =   0x00000000



NMI Status
=========================
Local NMI


Suggested Next Debug Steps
=========================

1] Check ELR to find the function and instruction that caused the exception.
2] Load the suspended task which caused the exception.
3] Check the client function which raised the assert.
4] Debug further as per the arguments passed and the conditions leading to the assert.




QURTK Flush Cache Status
=========================
0x1- QURT_error_info will be filled


QURTK_abnormal_reset_dump_status
=========================
0x3


QURT Exception Multiple
=========================
0x0


QuRT Error HW Thread 
=========================
HW TNUM	:	0x00000002


QURT Call stacks
=========================


Thread-2
File : core/debugtools/err/src/err_exception_handler.c
File Info: /data001/vc.integrator/EVENT-wave_high/EVENT_v015.148.060.high.oem_250903/nad/modem_proc/core/debugtools/err/src/err_exception_handler.c

-000|qurt_exception_raise_fatal()
-001|err_exception_handler()
-002|qurt_trampoline()
-003|qurt_trampoline()
----|end of frame

Registers context
r0:		0x00000001     |1
r1:		0x0
r2:		0xCAB72DA0     |3401002400
r3:		0x00000002     |2
r4:		0xC0DB7D04     |3235609860
r5:		0x01FF0014     |33488916
r6:		0x7FFFFFFF     |2147483647
r7:		0x3CD36340     |1020486464
r8:		0x0000157D     |5501
r9:		0xC0812560     |3229689184
r10:		0x00010000     |65536
r11:		0x00150049     |1376329
r12:		0x0
r13:		0x00010C00     |68608
r14:		0xC091C9D8     |3230779864
r15:		0x01FF0014     |33488916
r16:		0x0
r17:		0xCAB86300     |3401081600
r18:		0x05538042     |89358402
r19:		0x0
r20:		0xCAB86008     |3401080840
r21:		0x3CD36358     |1020486488
r22:		0x000000FF     |255
r23:		0xCAB866D8     |3401082584
r24:		0x3CD3638C     |1020486540
r25:		0x0
r26:		0x3CD363D0     |1020486608
r27:		0xD811CB80     |3625044864
r28:		0x7FFFFFFF     |2147483647
r29:		0x3CD36340     |1020486464
r30:		0x3CD363B0     |1020486576
r31:		0xD811CC24     |3625045028
elr:		0xC0DB7D04     |3235609860
ssr:		0x01F80014     |33030164
gp:		0xCB1E5000     |3407761408
ugp:		0x3CD363D0     |1020486608
sa0:		0xD811C9FC     |3625044476
lc0:		0x00000001     |1
sa1:		0x0
lc1:		0x0
m0:		0x0
m1:		0x0
preds:		0x00FF00FF     |16711935
usr:		0x00010C00     |68608
badva:		0x3CD3636C     |1020486508
tid:		0x00010000     |65536
cs0:		0x0
cs1:		0x0
ccr:		0x00150049     |1376329
rsvd:		0x0
g0:		0x0
g1:		0x0
g2:		0x0
g3:		0x0
framelimit:		0x3CD353C0     |1020482496
framekey:		0x33CFB022     |869249058



Error Start Time : 0x17F55CE0F36


QSH mini dump state
=========================
QSH_MINI_DUMP_COLLECT_STATE_DISABLED


Kernel Info
=========================
QURT Kernel ver.: 03.02.04.01.02.02.07


Core Config
=========================
Cache flushed      : 0x1
Chicken Bits       : 0x00002000
Chicken Bits rgdr  : 0x00000000
Chicken Bits duck  : 0x00000200
Chicken Bits turkey: 0x00000000
BQ Shared          : 0x0
QURTK_dmt_enabled  : 0x00000001
QURT system state  : 36
QURT ETM Config    : 0x00000000
QURT Testbus Cfg   : 0x00FF0040
QURTK_efuse_tcm_size : 0xFFFFFFFF
QURTK_nmi_status   : 0x00000000


Registers Info
=========================
Error cause: ERR_FATAL_EXIT, Application called blast_fatal_exit().

Global Registers:
syscfg      0095827D  sgp         C0812560
modectl     0000003F  imask0      0000EFBB
pcyclelo    FA677328  imask1      0000EF7B
pcyclehi    000009D0  imask2      0000EEFB
evb         C0816D00  imask3      0000EDFB
diag        00000000  context     CAB72DA0
ipendad     00000000  rsvd        00000000
rev         0000E267


local Registers:
r0          00000000  r8          00000000  r16         C8338BA0  r24         C9219D9F  lr          D9B99980
r1          00000003  r9          000007FF  r17         00000000  r25         CCCD4CCC  fp          C9219BA0
r2          B9020344  r10         3FAC78E8  r18         00000000  r26         C9219C70  sp          C9219B90
r3          000001EF  r11         C1506FE0  r19         00000000  r27         D888D2B0  elr         C08F47AC
r4          000001EF  r12         D624CE5C  r20         00000000  r28         00000000  ssr         019F0027
r5          00000003  r13         3FAC78E7  r21         CF812BC2  ugp         C9219C70  badva0      00000000
r6          FFFFFFFF  r14         00000005  r22         D886172C  gp          CB1E5000
r7          FFFFFFFF  r15         C081521C  r23         C833D038  pc          C08F47AC




Status Info
=========================

 hw_tnum : 2	 rsvd1 : 0		 cause2 : 0
 cause : 12	 rsvd2 : 0		 local_nmi : 1
 fatal : 1	 status : 1


User Errors
=========================

 error_tcb : 0xC08B8D60

 error_code : 0x00000008

 hw_thread : 0x00000002

 pcycle : 0x17F55CE0DF9

 Call Stack
 ======================
-000|:0xC08F47AC qurt_exception_raise_nonfatal()
-001|:0xD9B99980 fws_error_ipc()
-002|:0xD802512C fws_ipc_send()
-003|:0xD8892748 fw_diag_fatal_setup()
-004|:0xD886172C __fw_lte_s__867894996()
-005|:0xD8860D8C __fw_lte_s__391254659()
-006|:0xC0DB7724 qurt_trampoline()
-007|:0xC0DB7708 qurt_trampoline()
----|end of frame
ChatGPT said:

This core dump shows a firmware-side assertion failure (fatal) — useful and actionable. I’ll summarize what happened, why it likely happened, and give a prioritized list of concrete next-debug & mitigation steps you can run now.

Short summary (what happened)

Firmware image: MPSS.HI.3.2.c1-00163-SDX55_GENAUTO_PACK-1 (NAD/modem image).

Assertion (fatal) in lfw_common_cxn_mgr.c:264:

Assertion ((array_ptr->sf_info[cxn_id].proc_orders_done == array_ptr->sf_info[cxn_id].proc_orders_pend)
          || (array_ptr->sf_info[cxn_id].proc_orders_done == 0)) failed


→ proc_orders_done and proc_orders_pend are inconsistent (expected equal or done==0).

The code called qurt_fatal_exit() / qurt_exception_raise_nonfatal() → firmware aborted and produced SSR / trap.

QuRT SSR cause: ERR_FATAL_EXIT, cause code 0x0C (application called fatal exit). Local NMI noted.

Call stacks show the error surfaced through the firmware error/DIAG path (fw_diag_fatal_setup(), fws_ipc_send(), etc.).

BadVA / PC / ELR show the fault originated inside firmware thread that hit the assert (no hardware memory fault — it’s a software assert).

What that assertion means (diagnosis)

lfw_common_cxn_mgr appears to manage connection state / service-frame processing orders.

proc_orders_pend likely counts pending processing orders; proc_orders_done tracks completed ones. The assert expects either:

all pending orders are done (done == pend), or

done == 0 (fresh/cleared state).

The failure indicates a race or corruption:

orders were partially processed and counts became inconsistent (increment/decrement mismatch), or

cxn_id indexing corrupted / wrong array_ptr used, so fields refer to wrong cxn state, or

double-decrement, missed increment, or memory corruption on the structure, or

client/service attempted to exit while orders still in flight.

Given the stack, this happened while processing or exiting service resource (service_resource_exit() / FSM), so very likely a race/double-free during service shutdown or during a transition (e.g., SSR, resource disable, or modem restart).

This is a logical firmware bug (synchronization/ordering), not an external hardware crash.

Most likely root causes (ranked)

Race condition between producer/consumer of processing orders (missing/extra increment or decrement).

Use-after-free / stale pointer: array_ptr or sf_info[cxn_id] corrupted or reused for different connection.

Out-of-order shutdown: service/resource exit runs while pending orders still being processed (no gating).

Memory corruption elsewhere flipping counters.

Interaction with SSR/modem reset that left mid-state.

Immediate, concrete debug actions you can run now

(ordered by speed / value)

Correlate timestamps

Map the assert timestamp to other logs (QXDM, AOP, QRTR, RIL) to see preceding events (requests, timeouts, qmi_transport_error[-3], resets). If assert aligns with a modem reset or QRTR errors, include that in repro path.

Collect the full firmware crash dump + surrounding logs

Grab the full QuRT core dump, firmware DIAG logs before the assert (at least 5s—10s before). Attach QXDM entries around the same wall-clock time.

Symbolicate the ELR / PC and get source line

Use addr2line or the platform tools with the firmware ELF to map ELR/PC to exact function and line.

Example (on host with the firmware ELF):

addr2line -e lfw.elf 0xC0DB7D04


and for PC from QURT dump: addr2line -e <image> 0xC08F47AC

If you give me the available ELF/symbols addresses I can show exact function/line mapping.

Dump the lfw_common_cxn_mgr structure fields at crash time

From the core dump or live debug, print array_ptr contents:

proc_orders_pend, proc_orders_done, cxn_id, other related flags, lock state.

Look for negative/huge values or mismatched indices.

Check locking / concurrency around that code path

Inspect the source around service_resource_exit() and any code that modifies proc_orders_* — ensure modifications are protected by the same mutex/lock/atomic ops.

Search codebase for all writes to proc_orders_done and proc_orders_pend

Find increment/decrement sites and check for symmetrical updates, error paths where one may be skipped.

Reproduce with instrumentation

Add debug prints around modifications to those counters (log before/after, thread id, cxn_id).

Add sanity checks earlier to log if counters go negative or > threshold. This helps capture race windows.

Run stress / race tests

Under heavy load or forced SSRs, trigger service resource transitions to reproduce. If reproducible, narrow down the sequence that causes mismatch.

Check recent commits

If this code worked before, diff recent changes in connection manager / FSM / service exit code.

Quick mitigations (short-term)

If assert is causing product-level SSRs and you need temporary relief:

Add a defensive check (instead of assert) that logs the inconsistent state and attempts a safe reset or re-sync rather than fatal exit. (Only as short-term mitigation.)

Add extra gating in service_resource_exit() to wait for proc_orders_pend to drain or forcibly cancel pending orders safely.

How this ties to your earlier QMI/QRTR context

You previously saw qmi_transport_error[-3] timeouts and NAD alive checks. Two possible links:

Firmware assertion caused SSR and modem side resets — that could produce transient QMI/QRTR errors. (Check chronological order.)

Or long-standing QRTR transport issues triggered unexpected service exits in firmware that ended up in this race. Correlate exact times to confirm direction.

Example commands & files to run/inspect now

(put these where your build/debug environment can run them)

Map addresses:

# example: adjust path to the correct ELF for lfw/common image
arm-none-eabi-addr2line -e lfw.elf 0xC0DB7D04 -f -C


Search for counter ops:

grep -R "proc_orders_done" -n .
grep -R "proc_orders_pend" -n .


Print surrounding source at assertion:

sed -n '1,240p' lfw_common_cxn_mgr.c    # around line 264


If you have GDB/QuRT debugging tools, load the core and print struct at address:

# example in GDB connected to target/corefile:
p *array_ptr
p array_ptr->sf_info[cxn_id]

What I can do for you right now (if you share artifacts)

Parse/map ELR/PC addresses if you provide the firmware .elf with symbols (I’ll translate addresses to exact functions/lines).

Draft a concise bug report (one-pager) with timeline + required logs + repro steps to hand to firmware owners.

Suggest concrete code patches (e.g., atomic ops, locks, guard checks) once I can see the relevant source snippet.

Minimal prioritized checklist for you to follow now

Correlate crash timestamp with QXDM/QRTR logs (are QMI timeouts before or after?).

Extract and attach the full firmware core dump + symbol file (ELF).

Run addr2line on ELR/PC to get exact source location.

Dump the sf_info structure fields from core or add debug prints.

Search code for all updates to proc_orders_* and audit concurrency.

If you want, paste the lfw_common_cxn_mgr.c snippet around line ~240–300 here and I’ll read it and point exactly where the logic can break and suggest a small patch. Or attach the firmware ELF and I’ll symbolicate the addresses you pasted.

You said:
it is not related transport error
ChatGPT said:
Thought for 11s

Got it — thanks for clarifying. You’re right: the firmware assert in lfw_common_cxn_mgr.c looks like an internal logic/race problem and not a QRTR/QMI transport error. Short version and next steps you can take right away:

Why it’s not a transport error

The core shows a firmware assertion (proc_orders_done vs proc_orders_pend) and then a qurt_fatal_exit() — that is a deliberate software abort inside modem/NAD firmware.

Transport errors (QRTR/QMI timeouts) would show hardware/link layer faults, qmi_transport_error logs, or bus errors; here the failure is an application-level invariant violation inside the connection manager.

Registers / fault info don’t show a bus/mem fault — they show a logical assert, so the modem aborted itself, independent of QRTR packets.

Likely class of root cause

Race or ordering bug: increments/decrements of proc_orders_* are unsynchronized or out of order.

Double-free / stale pointer / index corruption for cxn_id or array_ptr.

Service/resource exit executed while processing orders still in-flight (missing gating).

Concrete immediate actions (high ROI)

Map the exact source line (if not already done): run addr2line with the modem ELF for the ELR/PC shown in the dump to get the exact function/line.

Dump the sf_info/array_ptr state at crash from the core (or add runtime dump): proc_orders_pend, proc_orders_done, cxn_id, locks/flags.

Search codebase for all writers/readers of proc_orders_done / proc_orders_pend and check symmetry (every increment has matching decrement under same lock).

grep -R "proc_orders_done" -n .
grep -R "proc_orders_pend" -n .


Audit locking around those counters — are they protected by the same mutex or atomic ops?

Add lightweight instrumentation (temporary): log increments/decrements with thread id and cxn_id, plus assert-trigger context (who requested exit). That helps reproduce the ordering that breaks the invariant.

Correlate timeline: check if this assert happens right after some external event (SSR, service restart, heavy load). That tells if an upstream action triggered an unsafe shutdown path.

Short-term mitigation (if product impact is severe): replace fatal assert() with a logged error + controlled cleanup/reset so SSR is avoided while you fix the root cause.

What I can help with right now

If you paste the lfw_common_cxn_mgr.c code around the assert (lines ~220–300) I’ll review and point exactly where a race or missing guard likely is and suggest a concrete patch.

If you provide the firmware ELF/symbol file I can symbolicate the addresses in your dump and show the exact function + source line.

I can draft a concise bug report (timeline, logs required, suspected root cause, suggested patch) you can hand to firmware owners.

Tell me which of the two you want me to do (review the source snippet, or symbolicate addresses), paste the file/addresses or snippet and I’ll analyze it right away.

You said:
0x0000017F55CD08E5:                           mcpm.c:2935     Tech 4 -- MCPM_Process_Req: Applied new configuration (mux + commit), SRR skip: 0, begin time = 0x17f55ccef27, end time = 0x17f55cd08c8, duration = 341 uSec.
0x0000017F55CD094F:                  mcpm_scenario.c:3323     mcpm_clockplan_log_resrc_values::mcpm sync scenario data: clk_proc: 0, q6: 0 ib: 0 ,mcpm cfg req data:clk_proc: 249600 q6: 576000 ib: 1804
0x0000017F55CD0A83:                           mcpm.c:3332     Tech 4--MCPM_Config_Modem: End of request: 46,end time = 0x17f55cd0a6a, duration = 447 uSec, pcycle = 0x9d0fa45060e capped clkproc count: 0
0x0000017F55CD0B7A:                           mcpm.c:3240     Tech 4--MCPM_Config_Modem: Start of request: 56, begin time = 0x17f55cd0b65, pcycle 0x9d0fa452389
0x0000017F55CD0BBB:                           mcpm.c:900      MCPM_MCVSConfig_Modem: Received MCVS request 2 from tech 4, update info: 0x800, clk_proc: 0 KHz, q6_clock: 0 KHz wmss: 0 fw_vpe_mvc_ptr: 0x0,fw_vpe_mcvs_ptr: 0xc897b4b0 fw_vpe_ceil_ptr: 0xc897b4d0
0x0000017F55CD0BE8:                           mcpm.c:931      MCPM_MCVSConfig_Modem: Start of MCVS request. timestamp = 0x17f55cd0bd5
0x0000017F55CD0C13:                  mcpm_drv_mcvs.c:1122     mcpm_drv_mcvs: servicing MCVS request 2, update_info 0x800, clk_proc 0 kHz, clk_q6 0 kHz from tech 4, begin time = 0x17f55cd0bff.
0x0000017F55CD0C45:                  mcpm_drv_mcvs.c:913      mcpm_drv_mcvs: servicing vector VPE MCVS request 2, update_info 0x800, mvc data ptr 0xc897b0c0, clk data ptr 0xc897b0e0, ceil data ptr 0xc897b100from tech 4, begin time = 0x17f55cd0c31.
0x0000017F55CD0CAF:                  mcpm_drv_mcvs.c:956      mcpm_drv_mcvs: finished vector VPE MCVS request 2 from tech 4, end time = 0x17f55cd0c9e, duration = 5 usec.
0x0000017F55CD0CCC:                  mcpm_drv_mcvs.c:1208     mcpm_drv_mcvs: finished MCVS request 2 from tech 4, end time = 0x17f55cd0cbc, duration = 9 usec.
0x0000017F55CD0D21:                           mcpm.c:1042     MCPM_MCVSConfig_Modem End   -- (Tech: 4) (Req: 2) (Timestamp: 0x17f55cd0d07) (Duration (us): 15) capped clk proc count: 0 (timestamp for capping: 0x000000000)
0x0000017F55CD0D3C:                           mcpm.c:3305     MCPM_Process_Req skipped, Config Modem call only contained MCVS req. (Req: 56) (update_info: 0x200)
0x0000017F55CD0D5A:                           mcpm.c:3332     Tech 4--MCPM_Config_Modem: End of request: 56,end time = 0x17f55cd0d47, duration = 25 uSec, pcycle = 0x9d0fa455bf6 capped clkproc count: 0
0x0000017F55CD0DBB:                      fws_sleep.c:190      FWS resume command: mask=0x00000020, apps=0x00000020, susp=0x00000000
0x0000017F55CD10AC:                rflte_mc_common.c:11471    rflte_mc_set_mcpm_lte_wakeup_status: LTE is calling wakeup set API =1, sub_id=0
0x0000017F55CD11EE:                       mcpm_drv.c:2402     MCPM_DRV Resource Query ::(Tech: 4)(Query Type: 0(Resrc ID: 0)(Fmax of query: 576000)
0x0000017F55CD1216:                       mcpm_drv.c:2402     MCPM_DRV Resource Query ::(Tech: 4)(Query Type: 0(Resrc ID: 3)(Fmax of query: 451000)
0x0000017F55CD1AC6:                           mcpm.c:3240     Tech 14--MCPM_Config_Modem: Start of request: 109, begin time = 0x17f55cd1aa0, pcycle 0x9d0fa46ec6c
0x0000017F55CD1CDD:                 rflte_dispatch.c:1998     RFA_RF_LTE_CDRX_WAKEUP_REQ: Received on LTE sub id 0
0x0000017F55CD1DB5:                  rflte_mc_data.c:3011     rflte_mc_data_reset_tx_tune_params: Reset Tx tune params done for sub_id 0
0x0000017F55CD1E26:             rflte_mc_tx_config.c:8727     rflte_mc_tx_cdrx_wakeup: cdrx wake up for carrier 0, band 2, handle 29
0x0000017F55CD1E42:                  rflte_mc_data.c:1193     rflte_mc_data_set_active_sub_id: sub_id[0],old active sub_id[0]
0x0000017F55CD1EAE:               mcpm_sys_configs.c:18987    MCPM_Sys_Config: Tech state = 3  Tech 14
0x0000017F55CD1EC3:               mcpm_sys_configs.c:18991    MCPM_Sys_Config: DownLink Rate = 0, UpLink Rate = 0, RF BW = 0
0x0000017F55CD1F34:              mcpm_tech_cfg_drv.c:407      total duration of mcpm_rm_dyn_merge_resources: 2 uSec tech : 14
0x0000017F55CD1F65:              mcpm_tech_cfg_drv.c:455      total duration of mcpm_rm_mux_configs : 0 uSec
0x0000017F55CD210D:                           mcpm.c:2122     MCPM_Process_Req::sleep stats:{ Q6 PC count: 776316 PC duration tick: 433292 PC cycle:776316 RPM Assisted PC: 240367 DDR PC count: 239184 CX Retention count: 239176 AOSS sleep count: 239175 }
0x0000017F55CD2132:                           mcpm.c:2130     MCPM_Process_Req: Matched system config IDs:   56   29    0, nbr bmask: 0x0 0x0 0x0 PC duration tick: 433292, PC count q6:776316 rpm:240367
0x0000017F55CD216B:                        mcpm_rm.c:3639     Tech 14--MCPM_RM: Commit resources - Increase/ON pass.
0x0000017F55CD21CE:                        mcpm_rm.c:3695     Tech 14--Resource 11 pending state is DC, so skipping commit
0x0000017F55CD21E0:                        mcpm_rm.c:3695     Tech 14--Resource 8 pending state is DC, so skipping commit
0x0000017F55CD21F3:                        mcpm_rm.c:3695     Tech 14--Resource 9 pending state is DC, so skipping commit
0x0000017F55CD2204:                        mcpm_rm.c:3695     Tech 14--Resource 10 pending state is DC, so skipping commit
0x0000017F55CD2219:                        mcpm_rm.c:3695     Tech 14--Resource 0 pending state is DC, so skipping commit
0x0000017F55CD222E:                        mcpm_rm.c:3695     Tech 14--Resource 3 pending state is DC, so skipping commit
0x0000017F55CD2245:                        mcpm_rm.c:3695     Tech 14--Resource 12 pending state is DC, so skipping commit
0x0000017F55CD225A:                        mcpm_rm.c:3695     Tech 14--Resource 14 pending state is DC, so skipping commit
0x0000017F55CD226F:                        mcpm_rm.c:3695     Tech 14--Resource 42 pending state is DC, so skipping commit
0x0000017F55CD2283:                        mcpm_rm.c:3695     Tech 14--Resource 33 pending state is DC, so skipping commit
0x0000017F55CD25E6:       mcpm_resrc_modem_offline.c:1532     mcpm_resrc_modem_local_commit: tech (14), state (1), sched (0), sched_state (0), pwrd_down (0)
0x0000017F55CD2646:    tcxomgr_rot_client_handling.c:613      tcxomgr_get_client_rgs: Temp: 23219 Rot: 2203 VCO Type: 13 Uncertainty: 1 system: 13 AS_ID: 0
0x0000017F55CD26A1:                        mcpm_rm.c:3695     Tech 14--Resource 38 pending state is DC, so skipping commit
0x0000017F55CD26B6:                        mcpm_rm.c:3695     Tech 14--Resource 39 pending state is DC, so skipping commit
0x0000017F55CD26FF:                        mcpm_rm.c:3695     Tech 14--Resource 16 pending state is DC, so skipping commit
0x0000017F55CD27C0:                mcpm_npa_vector.c:381      MCPM_NPA_VECTOR: Imm resrc 19 req for 249600, tech 14
0x0000017F55CD294A:                        mcpm_rm.c:3695     Tech 14--Resource 31 pending state is DC, so skipping commit
0x0000017F55CD2965:                        mcpm_rm.c:3695     Tech 14--Resource 40 pending state is DC, so skipping commit
0x0000017F55CD297F:                        mcpm_rm.c:3695     Tech 14--Resource 41 pending state is DC, so skipping commit
0x0000017F55CD299B:                        mcpm_rm.c:3695     Tech 14--Resource 36 pending state is DC, so skipping commit
0x0000017F55CD29AE:                        mcpm_rm.c:3695     Tech 14--Resource 37 pending state is DC, so skipping commit
0x0000017F55CD29C7:                        mcpm_rm.c:3695     Tech 14--Resource 18 pending state is DC, so skipping commit
0x0000017F55CD29E4:                        mcpm_rm.c:3695     Tech 14--Resource 45 pending state is DC, so skipping commit
0x0000017F55CD2A1D:                           mcpm.c:2935     Tech 14 -- MCPM_Process_Req: Applied new configuration (mux + commit), SRR skip: 0, begin time = 0x17f55cd1ff5, end time = 0x17f55cd29f9, duration = 133 uSec.
0x0000017F55CD2A95:              rfcommon_core_xpt.c:3243     rfcommon_xpt_init_tx_lite: Init Tx RFM Mode 8, Device 18, Tx handle 29, Cal mode 0
0x0000017F55CD2BB4:                           mcpm.c:3332     Tech 14--MCPM_Config_Modem: End of request: 109,end time = 0x17f55cd2b8a, duration = 225 uSec, pcycle = 0x9d0fa48e7dc capped clkproc count: 0
0x0000017F55CD2F0F:          rflm_dtr_tx_lut_ctl.cpp:148      rflm_dtr_tx_lut_load_dpd_tbls: Txlm_chain 0, Tx_Handle : 29, Table_type : 2.
0x0000017F55CD2FF1:          rflm_dtr_tx_lut_ctl.cpp:148      rflm_dtr_tx_lut_load_dpd_tbls: Txlm_chain 0, Tx_Handle : 29, Table_type : 4.
0x0000017F55CD3050:                rflte_mc_common.c:10019    rflte_mc_carrier_activate: sub_id[0], is_dl_req = 1
0x0000017F55CD3088:                rflte_mc_common.c:10059    rflte_mc_carrier_activate: Rx Case: number of handles = 4, mode = 2
0x0000017F55CD3087:         rflm_xpt_dpd_lut_mgmt.cc:2368     rflm_xpt_dpd_lut_commit_data : time to load 1344
0x0000017F55CD3134:                rflte_mc_common.c:10114    rflte_mc_carrier_activate: handle = 3, nb = 0
0x0000017F55CD3148:                rflte_mc_common.c:10114    rflte_mc_carrier_activate: handle = 22, nb = 0
0x0000017F55CD315D:                rflte_mc_common.c:10114    rflte_mc_carrier_activate: handle = 26, nb = 0
0x0000017F55CD3171:                rflte_mc_common.c:10114    rflte_mc_carrier_activate: handle = 18, nb = 0
0x0000017F55CD320B:                rflte_mc_common.c:10138    rflte_mc_carrier_activate: Calling qlink policy update with chain_type = 0, chain_status = 1
0x0000017F55CD3260:          rflm_qlnk_policy_mgmt.c:2012     QSLEEP POLICY: 2G/3G VETO ALREADY CLEARED/NO-OP
0x0000017F55CD327F:          rflm_qlnk_policy_mgmt.c:2104     Qsleep policy: Qlink ID 0, sub id 0 tech 3 chain 0 chain status 1
0x0000017F55CD3280:            rfcommon_therm_intf.c:263      rfcommon_therm_start_service_intf: therm_obj =0x99c36540, qlink_id =0,subid= 0
0x0000017F55CD329F:          rflm_qlnk_policy_mgmt.c:2113     Qsleep policy: active Rx mask 0x8,txfe ip rate 25600
0x0000017F55CD32A2:               rfcommon_therm.cpp:1133     rfcommon_therm_mode_convert:therm tech id= 0 ,subid = 0
0x0000017F55CD32DE:               rfcommon_therm.cpp:1133     rfcommon_therm_mode_convert:therm tech id= 0 ,subid = 0
0x0000017F55CD32F3:               rfcommon_therm.cpp:1245     rfcommon_start_service:therm tech_id=0, qlink_id=0,subid =0
0x0000017F55CD33E4:                rflte_mc_common.c:10019    rflte_mc_carrier_activate: sub_id[0], is_dl_req = 0
0x0000017F55CD33FD:                rflte_mc_common.c:10144    rflte_mc_carrier_activate: Tx Case: number of handles = 1, mode = 0
0x0000017F55CD3444:               rfcommon_therm.cpp:496      rfcommon_therm_push_therm_obj: therm_obj =0x99c36540, band_info =2, qlink_id =0
0x0000017F55CD346D:            rfcommon_therm_intf.c:295      rfcommon_therm_start_service_intf: tech 8 start therm service,subid =0
0x0000017F55CD3479:      sdr865_dtr_tx_allocator.cpp:896      SUB6_QSLP_DEBUG: disable 1, UL usage has no change
0x0000017F55CD34B1:          rflm_qlnk_policy_mgmt.c:2012     QSLEEP POLICY: 2G/3G VETO ALREADY CLEARED/NO-OP
0x0000017F55CD34CE:          rflm_qlnk_policy_mgmt.c:2104     Qsleep policy: Qlink ID 0, sub id 0 tech 3 chain 1 chain status 1
0x0000017F55CD34E3:          rflm_qlnk_policy_mgmt.c:2113     Qsleep policy: active Rx mask 0x8,txfe ip rate 25600
0x0000017F55CD3546:                rflte_mc_common.c:10203    rflte_mc_carrier_activate: qlink policy update called for tx with chain_type = 1, chain_status = 1, tx ip rate = 25600
0x0000017F55CD355B:                 rflte_dispatch.c:2020     RFA_RF_LTE_CDRX_WAKEUP_CNF for Rx CNF Sent successful, with result = 1
0x0000017F55CD383C:                rflte_mc_common.c:10019    rflte_mc_carrier_activate: sub_id[0], is_dl_req = 1
0x0000017F55CD3854:                rflte_mc_common.c:10059    rflte_mc_carrier_activate: Rx Case: number of handles = 4, mode = 2
0x0000017F55CD3898:                rflte_mc_common.c:10114    rflte_mc_carrier_activate: handle = 3, nb = 0
0x0000017F55CD38A9:                rflte_mc_common.c:10114    rflte_mc_carrier_activate: handle = 22, nb = 0
0x0000017F55CD38B9:                rflte_mc_common.c:10114    rflte_mc_carrier_activate: handle = 26, nb = 0
0x0000017F55CD38CA:                rflte_mc_common.c:10114    rflte_mc_carrier_activate: handle = 18, nb = 0
0x0000017F55CD38FE:                rflte_mc_common.c:10138    rflte_mc_carrier_activate: Calling qlink policy update with chain_type = 0, chain_status = 1
0x0000017F55CD3918:          rflm_qlnk_policy_mgmt.c:2012     QSLEEP POLICY: 2G/3G VETO ALREADY CLEARED/NO-OP
0x0000017F55CD3933:          rflm_qlnk_policy_mgmt.c:2104     Qsleep policy: Qlink ID 0, sub id 0 tech 3 chain 0 chain status 1
0x0000017F55CD3947:          rflm_qlnk_policy_mgmt.c:2113     Qsleep policy: active Rx mask 0x8,txfe ip rate 25600
0x0000017F55CD4095:                           mcpm.c:3240     Tech 4--MCPM_Config_Modem: Start of request: 56, begin time = 0x17f55cd4076, pcycle 0x9d0fa4b5b8d
0x0000017F55CD40D3:                           mcpm.c:900      MCPM_MCVSConfig_Modem: Received MCVS request 2 from tech 4, update info: 0xc00, clk_proc: 844800 KHz, q6_clock: 0 KHz wmss: 0 fw_vpe_mvc_ptr: 0x0,fw_vpe_mcvs_ptr: 0xc083aa48 fw_vpe_ceil_ptr: 0xc083aa68
0x0000017F55CD4104:                           mcpm.c:931      MCPM_MCVSConfig_Modem: Start of MCVS request. timestamp = 0x17f55cd40e9
0x0000017F55CD4141:                  mcpm_drv_mcvs.c:1122     mcpm_drv_mcvs: servicing MCVS request 2, update_info 0xc00, clk_proc 844800 kHz, clk_q6 0 kHz from tech 4, begin time = 0x17f55cd412a.
0x0000017F55CD4177:                  mcpm_drv_mcvs.c:913      mcpm_drv_mcvs: servicing vector VPE MCVS request 2, update_info 0xc00, mvc data ptr 0xc083a658, clk data ptr 0xc083a678, ceil data ptr 0xc083a698from tech 4, begin time = 0x17f55cd415e.
0x0000017F55CD41F8:                mcpm_vector_vpe.c:311      VPE vote: (client/tech 0x0)(non-shared 844800)(shared 12000 302661 248314 94118 85518 0 0)
0x0000017F55CD4D36:           mcpm_resrc_modem_pll.c:1046     mcpm_resrc_modem_pll: configured clocks (clk_proc: 844800, vq6: 1056000)
0x0000017F55CD4E1A:                  mcpm_drv_mcvs.c:956      mcpm_drv_mcvs: finished vector VPE MCVS request 2 from tech 4, end time = 0x17f55cd4e01, duration = 168 usec.
0x0000017F55CD4E3C:                  mcpm_drv_mcvs.c:1208     mcpm_drv_mcvs: finished MCVS request 2 from tech 4, end time = 0x17f55cd4e29, duration = 173 usec.
0x0000017F55CD4EA1:                           mcpm.c:1042     MCPM_MCVSConfig_Modem End   -- (Tech: 4) (Req: 2) (Timestamp: 0x17f55cd4e84) (Duration (us): 181) capped clk proc count: 0 (timestamp for capping: 0x000000000)
0x0000017F55CD4EC1:                           mcpm.c:3305     MCPM_Process_Req skipped, Config Modem call only contained MCVS req. (Req: 56) (update_info: 0x200)
0x0000017F55CD4EDE:                           mcpm.c:3332     Tech 4--MCPM_Config_Modem: End of request: 56,end time = 0x17f55cd4ecb, duration = 191 uSec, pcycle = 0x9d0fa4d097b capped clkproc count: 0
0x0000017F55CD5B70:             os_api_gnss_socket.c:2305     Start qPoll on 1 sockFDs
0x0000017F55CD5BB5:             os_api_gnss_socket.c:250      v_Initialized:1 l_clientSockHdl 37406 l_numSockFds 1 sockFD:37405 -1 -1 Error 0
0x0000017F55CD5CE0:                     coex_algos.c:11771    MCS_CXM: Sleep duration rcvd, tech: 0 is_going_to_sleep: 0, duration: 10
0x0000017F55CD64A6:                rflm_lte_dm_oft.c:1788     rflm_lte_dm_get_phy_nb_index: Handle 29 maps CC_idx 0 to Phy_NB_idx 0
0x0000017F55CD64B9:                rflm_lte_dm_oft.c:1793     rflm_lte_dm_get_phy_nb_index: all DTR Phy NB indices set!
0x0000017F55CD888F:   rflte_dm_common_build_script.c:340      rflte_fed_update_qlink_info(): script_buf:0x9a5513a0, max_size_bytes:164, qlink_blk_size_bytes:140, dm_mem_ptr:0xc1c24514
0x0000017F55CDA4CA:                        VAdcLog.c:166      VADC EOC
0x0000017F55CDA787:                        VAdcLog.c:222      VADC conv result eStatus 0, nPhysical 23222, uPercent 34577, uMicrovolts 989273, uCode 15248
0x0000017F55CDAEE9:                    tcxomgr_cal.c:2549     XO temp : 23222, rot: 2151, table: 0
0x0000017F55CDB003:                       mc_fee.cpp:1616     Best Aged Func 102 d_Temp 5929 d_Time 638827
0x0000017F55CDB03D:                       mc_fee.cpp:2141     SV Meas/PE fix Bias 2216, FUNC 102, Src 2
0x0000017F55CDB06D:                       mc_fee.cpp:2239     getGpsBiasAndFunc Bias 2216, FUNC 102, Src 1 (2)
0x0000017F55CDB130:                   tcxomgr_data.c:2961     Retrieve RGS Temp: 23222 Rot: 2202 VCO Type: 13 Uncertainty: 1 system: 13
0x0000017F55CDB363:                   tcxomgr_data.c:2961     Retrieve RGS Temp: 23222 Rot: 2202 VCO Type: 13 Uncertainty: 1 system: 13
0x0000017F55CDB3C1:                   mc_freqest.cpp:1320     Rpush is still ON when GPS is OFF.
0x0000017F55CDBAFE:                            gts.c:3708     Processing FEST Msg. Src 1 Est 2269184 Unc 841 Cal 11 DelayCtr 87 B2bDiffMs 25 NumCtr 190
0x0000017F55CDBB2F:                            gts.c:3715     FEST tag. Ref 2 25 8941774 W 1 8161919 Msec 547864328
0x0000017F55CDC566:                    rflm_lte_rx.c:9308     rflm_lte_rx_configure_chain_hw(): debug_var 0x100200
0x0000017F55CDCBAA:                    rflm_lte_rx.c:9308     rflm_lte_rx_configure_chain_hw(): debug_var 0x100210
0x0000017F55CDCDEA:                    rflm_lte_rx.c:9308     rflm_lte_rx_configure_chain_hw(): debug_var 0x100220
0x0000017F55CDD053:                    rflm_lte_rx.c:9308     rflm_lte_rx_configure_chain_hw(): debug_var 0x100230
0x0000017F55CDF44C:                mcpm_vector_vpe.c:311      VPE vote: (client/tech 0x204)(non-shared 249600)(shared 0 0 0 0 0 0 249600)
0x0000017F55EA7C35:                     uart_debug.c:265      [3] GPIO 44: config should be 0x0001c2c1
0x0000017F55EA7C6B:                     uart_debug.c:266      [3] GPIO 44: config is 0x0001c2c1
0x0000017F55EA7CB3:                     uart_debug.c:265      [3] GPIO 45: config should be 0x000002d1
0x0000017F55EA7CDF:                     uart_debug.c:266      [3] GPIO 45: config is 0x000002d1
0x0000017F561BD40C:         rflm_ccs_rfc_hal_mdm.cpp:1091     dg: RFCCS logging crashdump: call MRFC flush
0x0000017F561BD445:         rflm_ccs_rfc_hal_mdm.cpp:1172     RFCCS logging crashdump: rflm_css_pdmem_byte_cnt invalid 0
0x0000017F573211DB:               rfcommon_debug.cpp:448      START RF Crash Dump Info. Updating rfcommon_crash_handler_state to RFM_CRASH_HANDLER_STARTED
0x0000017F57321202:               rfcommon_debug.cpp:459      Started saving RF registers
0x0000017F57321244:               rfcommon_debug.cpp:477      RF Task init reached? = 1 state 2 is completed? = 1
0x0000017F57321287:               rfcommon_debug.cpp:482      RFM init state 1 is pass? = 1 took 912051 us
0x0000017F573212B9:               rfcommon_debug.cpp:485      RF common init status pass? = 1
0x0000017F573212DC:               rfcommon_debug.cpp:488      RF QLINK init status pass? = 1
0x0000017F573213EF:                      rfc_cmw.cpp:19759    RFC CMW HWID 520 FSID 4 BID 5 XML Version 6 Init Status 2 is success? = 1
0x0000017F57321438:                      rfc_cmw.cpp:19768    RFC CMW Bands Mask bin 0 mask 0x0001980000000000
0x0000017F57321466:                      rfc_cmw.cpp:19768    RFC CMW Bands Mask bin 1 mask 0xDF00300008BF0000
0x0000017F57321495:                      rfc_cmw.cpp:19768    RFC CMW Bands Mask bin 2 mask 0xFFC88503E2BB1F3B
0x0000017F573214C5:                      rfc_cmw.cpp:19768    RFC CMW Bands Mask bin 3 mask 0x0000000001000314
0x0000017F573214FE:                      rfc_cmw.cpp:19777    RFC CMW Techs Bands Mask bin 0 mask 0x0001980000000000
0x0000017F5732152B:                      rfc_cmw.cpp:19777    RFC CMW Techs Bands Mask bin 1 mask 0xDF00300008BF0000
0x0000017F5732155A:                      rfc_cmw.cpp:19777    RFC CMW Techs Bands Mask bin 2 mask 0xFFC88503E2BB1F38
0x0000017F5732158A:                      rfc_cmw.cpp:19777    RFC CMW Techs Bands Mask bin 3 mask 0x0000000001000314
0x0000017F573215CB:                      rfc_cmw.cpp:19787    RFC CMW Techs Bands Mask v2 sub_high bin 0 mask 0x0001980000000000
0x0000017F573215F7:                      rfc_cmw.cpp:19793    RFC CMW Techs Bands Mask v2 sub_low bin 0 mask 0x0001980000000000
0x0000017F57321624:                      rfc_cmw.cpp:19787    RFC CMW Techs Bands Mask v2 sub_high bin 1 mask 0xDF00300008BF0000
0x0000017F57321653:                      rfc_cmw.cpp:19793    RFC CMW Techs Bands Mask v2 sub_low bin 1 mask 0xC500000000000000
0x0000017F57321683:                      rfc_cmw.cpp:19787    RFC CMW Techs Bands Mask v2 sub_high bin 2 mask 0x00088503E2BB1F38
0x0000017F573216B1:                      rfc_cmw.cpp:19793    RFC CMW Techs Bands Mask v2 sub_low bin 2 mask 0x00000000A0880800
0x0000017F573216E1:                      rfc_cmw.cpp:19787    RFC CMW Techs Bands Mask v2 sub_high bin 3 mask 0x0000000000000200
0x0000017F5732170B:                      rfc_cmw.cpp:19793    RFC CMW Techs Bands Mask v2 sub_low bin 3 mask 0x0000000000000200
0x0000017F57321743:                      rfc_cmw.cpp:19872    RFC CA enabled? 1
0x0000017F57321777:                      rfc_cmw.cpp:19875    RFC CA Debug Info is now offline. Details are in offline items.
0x0000017F573217B7:                 rfc_cmw_intf.cpp:6013     RFCp MMW is NULL, no debug info available
0x0000017F57321835:               rfcommon_debug.cpp:591      RF OVERALL tech init status pass? = 1
0x0000017F57321873:               rfcommon_debug.cpp:593      RF CDMA tech init status pass? = 1 took 0 us
0x0000017F573218A0:               rfcommon_debug.cpp:595      RF GSM tech init status pass? = 1 took 1624 us
0x0000017F573218C6:               rfcommon_debug.cpp:597      RF LTE tech init status pass? = 1 took 33028 us
0x0000017F573218ED:               rfcommon_debug.cpp:599      RF NR5G tech init status pass? = 1 took 17166 us
0x0000017F5732191B:               rfcommon_debug.cpp:601      RF TDSCDMA tech init status pass? = 1 took 0 us
0x0000017F57321940:               rfcommon_debug.cpp:603      RF WCDMA tech init status pass? = 1 took 64300 us
0x0000017F5732196A:               rfcommon_debug.cpp:256      START rfcommon_debug_rffe_snapshot. Updating rfcommon_crash_handler_state to RFM_CRASH_HANDLER_RFFE_DUMP_STAGE
0x0000017F57759FD8:               rfcommon_debug.cpp:337      RFFE dump done 230
0x0000017F57C5F955:               rfcommon_debug.cpp:628      Finished saving RF registers
0x0000017F57C5F97D:               rfcommon_debug.cpp:637      RF crash handler done. Updating rfcommon_crash_handler_state to RFM_CRASH_HANDLER_COMPLETED
0x0000017F57C5F9FA:                        cc_dmov.c:2056     CC is disabled state - ignoring DMOV Dump Request at Modem Error
ChatGPT said:

Good — you’ve posted a detailed modem trace excerpt.

Let’s interpret it carefully:

🔹 Context Summary

From these logs we can see:

Subsystem: LTE / Modem Power Management (MCPM)

Tech IDs: 4 (LTE), 14 (maybe RF/LTE TX)

Main modules: mcpm.c, mcpm_drv_mcvs.c, rflte_mc_common.c, rflm_*

Sequence: modem wakeup (from CDRX), resource configuration, PLL and clock setup, thermal and RF initialization, then an eventual crash dump from RF subsystem.

🔹 Key Observations

Normal CDRX wakeup flow:

rflte_mc_set_mcpm_lte_wakeup_status
RFA_RF_LTE_CDRX_WAKEUP_REQ
MCPM_Config_Modem
MCPM_MCVSConfig_Modem


➜ LTE sub-system is waking up from sleep; modem clocks and Q6 are configured again.

MCVS and MCPM activities:

MCPM_MCVSConfig_Modem: Received MCVS request 2
mcpm_drv_mcvs: servicing MCVS request
mcpm_resrc_modem_pll: configured clocks (clk_proc: 844800, vq6: 1056000)


➜ Clock configuration is proceeding normally; no sign of power collapse or sync failure.

RF layer activities:

rflte_mc_carrier_activate
rfcommon_therm_start_service_intf
rfcommon_xpt_init_tx_lite


➜ TX/RX paths and thermal control initialization look okay. All normal post-wakeup operations.

Then the crash happens later:

rflm_ccs_rfc_hal_mdm.cpp:1091  RFCCS logging crashdump: call MRFC flush
rflm_ccs_rfc_hal_mdm.cpp:1172  RFCCS logging crashdump: rflm_css_pdmem_byte_cnt invalid 0
rfcommon_debug.cpp:448          START RF Crash Dump Info


➜ The RF subsystem (RFCCS) triggered a crash dump.
The key line:

rflm_css_pdmem_byte_cnt invalid 0


means a memory pointer or size corruption occurred — often due to a firmware internal failure, not due to transport or NAD issue.

🔹 So, to answer directly:

Is this related to transport error?
No.

There is no sign of NAD transport failure (no “DLT_TRANSPORT_ERROR”, “NAD_ALIVE_STATUS fail”, “IPC timeout”, or “host link down” entries).

The failure is inside the modem’s RF control software (rflm_ccs_rfc_hal_mdm), after successful LTE wakeup and configuration, so:

The transport link between AP ↔ modem was fine.

The modem firmware itself entered a crash condition in RFCCS (RF control core).

🔹 Possible causes

Corrupted RFCCS PD memory (rflm_css_pdmem_byte_cnt = 0)

Timing mismatch in RFCCS register flush sequence

Modem internal assert triggered by invalid LUT or calibration state

🔹 Suggestion for next step

If you’re debugging this in a thermal or stability context:

Check before the crash:

Any “thermal mitigation”, “XO temp” (you have tcxomgr_cal.c and VADC logs) to see if overheating caused a chain failure.

Correlate timestamps: find whether crash aligns with MCCP or RF resource transitions.

Verify modem image stability: this matches a firmware RF crash, not transport or NAD.

Would you like me to pinpoint exactly which sequence or request triggered the crash (based on timestamps and tech IDs 4/14)? I can trace that step-by-step from this log.

You said:
what is issue tell me in understandable manner
ChatGPT said:

Sure 👍 let’s simplify it clearly —

🧠 What happened

Your modem was working fine initially — it woke up from sleep (CDRX), set up clocks, RF, and LTE layers.
Then suddenly the modem crashed internally while doing RF (radio) operations — specifically inside a module called
rflm_ccs_rfc_hal_mdm.cpp (this handles LTE transmit/receive control).

⚙️ What the crash means

The log shows this key error:

rflm_css_pdmem_byte_cnt invalid 0


That means:

The modem’s RF firmware tried to access or use a memory buffer (PD memory), but that buffer size or address was 0 or invalid.

Because of that, the modem’s internal safety check triggered a crash dump —
to prevent further damage or unstable radio behavior.

So, it’s like:

“Modem tried to read/write from an empty memory area → caught the error → crashed intentionally (assert).”

🚫 What it is not

❌ It’s not a NAD (Network Access Device) transport issue.
(No PCIe, QRTR, or QMI transport errors seen.)

❌ It’s not caused by AP (Android/Linux side).
The AP side was fine.

❌ It’s not a temperature overheat or power collapse event.

🔍 The real issue

👉 The modem firmware (on SDX55) hit an internal RF crash during radio setup or data transmission.
Specifically, inside the RFCCS (RF Control Core Subsystem).
This is purely a modem-side bug or memory corruption.

🧩 What can be done

Report this crash signature
→ lfw_common_cxn_mgr.c:264 Assertion failed
→ rflm_css_pdmem_byte_cnt invalid 0

to the modem firmware or BSP team — they’ll correlate it with known defects.

Check if it repeats:
If this crash happens repeatedly after modem wakeup or data session start, it’s likely a reproducible firmware defect.

Collect logs:

QXDM log (you already have it ✅)

DLT + QRTR logs from AP side to confirm communication before crash.

🧾 Simple Summary
Layer	Status
NAD (PCIe / QRTR)	Working fine
QMI Transport	OK (no -3 errors)
LTE wakeup sequence	Completed successfully
Modem firmware	Crashed in RF section
Root cause	Invalid memory (PD buffer = 0) in RFCCS code
Fix needed	From modem firmware side (not BSP side)

Would you like me to explain what “PD memory” and “RFCCS” are in simple terms (so you understand why invalid memory caused crash)?

You said:
 10638.816826:   <0> Freezing user space processes ... 
 10638.818686:   <2> f_cdev_poll: Failed due to NULL device or disconnected.
 10638.820256:   <2> (elapsed 0.003 seconds) done.
 10638.820275:   <2> OOM killer disabled.
 10638.820279:   <2> Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
 10638.821792:   <2> printk: Suspending console(s) (use no_console_suspend to debug)
 10638.823545:   <2> qcom-ethqos qcom_ethqos_suspend:4950 driver load failed
 10638.825339:   <2> 	[AK7759] ak7759_set_bias_level(4034)
 10638.825345:   <2> 	[AK7759] SND_SOC_BIAS_OFF
 10638.826121:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10638.826196:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10638.826561:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10638.826630:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10638.826686:   <2> 	[AK7759] ak7759_set_bias_level(4034)
 10638.826688:   <2> 	[AK7759] SND_SOC_BIAS_OFF
 10638.827057:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10638.827131:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10638.827507:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10638.827577:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10638.834234:   <2> gic_show_resume_irq: 202 triggered lge_ap2nad_wakeup_interrupt
 10638.834264:   <2> PM: pm_system_irq_wakeup: 89 triggered lge_ap2nad_wakeup_interrupt
 10638.835591:   <2> [LGE] AP2NAD_WAKEUP gpio is asserted to HIGH from i.mx
 10638.835595:   <2> [LGE] register wakeup source
 10638.835610:   <2> [LGE] NAD2AP_WAKEUP GPIO is configured to 0
 10638.838678:   <2> 	[AK7759] ak7759_resume(4381)
 10638.838691:   <2> 	[ak7759] ak7759_resume External PDN[OFF]
 10638.839696:   <2> 	[ak7759] ak7759_resume External PDN[ON]
 10638.840728:   <2> [AK7759] ak7759_write_register (84, 2)
 10638.840733:   <2> [AK7759] ak7759_write_register (85, 1)
 10638.841030:   <2> 	[AK7759] ak7759_set_bias_level(4034)
 10638.841034:   <2> [AK7759] SND_SOC_BIAS_STANDBY
 10638.841084:   <2> [LGE] register wakeup source for pm
 10638.841875:   <2> qcom-ethqos qcom_ethqos_resume:5022 driver load failed
 10638.843884:   <2> OOM killer enabled.
 10638.843890:   <2> Restarting tasks ... done.
 10638.857033:   <2> ipa ipa_pm_notify:498 Entry
 10638.857046:   <2> ipa ipa_pm_notify:510 Exit
 10638.857061:   <2> Resume caused by IRQ 89, lge_ap2nad_wakeup_interrupt
 10638.857076:   <2> PM: suspend exit
 10638.874086:   <2> [0x188820 mhi_sm_pcie_event_manager] Handling EP_PCIE_PM_RST_DEAST_EVENT event, current states: M3 and D3_COLD_STATE
 10638.874515:   <2> ep_pcie_reset_init: After Reset assert pcie_core_reset
 10638.875610:   <2> ep_pcie_reset_init: After Reset de-assert pcie_core_reset
 10638.875633:   <2> ep_pcie_reset_init: After Reset assert pcie_phy_reset
 10638.876727:   <2> ep_pcie_reset_init: After Reset de-assert pcie_phy_reset
 10638.877290:   <2> ep_pcie_core_enable_endpoint: PCIe V1711211: number of PERST retries:0.
 10638.877305:   <2> ep_pcie_phy_init: PCIe V1711211: Unexpected phy version 2103 is caught
 10638.879532:   <2> ep_pcie_core_enable_endpoint: PCIe V1711211: PCIe  PHY is ready
 10638.879641:   <2> ep_pcie_core_init: PCIe V1711211: PCIE20_PARF_INT_ALL_MASK:0x210e
 10638.907308:   <2> ep_pcie_core_enable_endpoint: PCIe V1711211: link initialized for LE PCIe endpoint
 10638.907317:   <2> PCIe - link initialized for LE PCIe endpoint
 10638.911879:   <2> [0x188820 mhi_sm_pcie_event_manager] Handling EP_PCIE_PM_D0_EVENT event, current states: M3 and D0_STATE
 10638.944228:   <2> [0x188820 mhi_dev_notify_sm_event] received: MHI_DEV_EVENT_M0_STATE
 10638.944277:   <2> [0x188820 mhi_sm_dev_event_manager] Handling MHI_DEV_EVENT_M0_STATE event, current states: M3 & D0_STATE
 10638.945610:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10638.946927:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10638.954095:   <2> [LGE] AP2NAD_WAKEUP gpio is asserted to HIGH from i.mx
 10638.954113:   <2> [LGE] register wakeup source
 10638.954130:   <2> [LGE] NAD2AP_WAKEUP GPIO is configured to 0
 10639.517642:   <2> msm-dwc3 a600000.ssusb: DWC3 exited from low power mode
 10639.882255:   <2> android_work: sent uevent USB_STATE=CONNECTED
 10639.886116:   <2> android_work: sent uevent USB_STATE=DISCONNECTED
 10640.039169:   <2> android_work: sent uevent USB_STATE=CONNECTED
 10640.063540:   <2> configfs-gadget gadget: high-speed config #1: c
 10640.065672:   <2> android_work: sent uevent USB_STATE=CONFIGURED
 10713.656050:   <2> android_work: sent uevent USB_STATE=DISCONNECTED
 10713.670946:   <2> msm-dwc3 a600000.ssusb: DWC3 in low power mode
 10714.039333:   <2> [0x188820 mhi_dev_notify_sm_event] received: MHI_DEV_EVENT_M3_STATE
 10714.039387:   <2> [0x188820 mhi_sm_dev_event_manager] Handling MHI_DEV_EVENT_M3_STATE event, current states: M0 & D0_STATE
 10714.045333:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10714.046590:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10714.047915:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10714.049140:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10714.051574:   <2> ipa_dma ipa3_dma_disable:491 There is pending work, can't disable.
 10714.051587:   <2> [0x188820 mhi_sm_prepare_suspend] IPA disable fail cnt:0
 10714.063474:   <2> [0x188820 mhi_sm_prepare_suspend] IPA DMA successfully disabled
 10714.077110:   <2> [0x188820 mhi_sm_pcie_event_manager] Handling EP_PCIE_PM_D3_HOT_EVENT event, current states: M3 and D0_STATE
 10714.096421:   <2> [0x188820 mhi_sm_pcie_event_manager] Handling EP_PCIE_PM_D3_COLD_EVENT event, current states: M3 and D3_HOT_STATE
 10714.575472:   <2> PM: suspend entry (deep)
 10714.582405:   <2> Filesystems sync: 0.006 seconds
 10714.582427:   <2> ipa ipa_pm_notify:498 Entry
 10714.582437:   <2> ipa ipa_pm_notify:510 Exit
 10714.585326:   <0> Freezing user space processes ... 
 10714.587147:   <2> f_cdev_poll: Failed due to NULL device or disconnected.
 10714.588707:   <2> (elapsed 0.003 seconds) done.
 10714.588727:   <2> OOM killer disabled.
 10714.588732:   <2> Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
 10714.590068:   <2> printk: Suspending console(s) (use no_console_suspend to debug)
 10714.591718:   <2> qcom-ethqos qcom_ethqos_suspend:4950 driver load failed
 10714.593516:   <2> 	[AK7759] ak7759_set_bias_level(4034)
 10714.593522:   <2> 	[AK7759] SND_SOC_BIAS_OFF
 10714.593892:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10714.593941:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10714.594462:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10714.594531:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10714.594587:   <2> 	[AK7759] ak7759_set_bias_level(4034)
 10714.594589:   <2> 	[AK7759] SND_SOC_BIAS_OFF
 10714.594961:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10714.595031:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10714.595392:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10714.595461:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10714.602098:   <2> gic_show_resume_irq: 202 triggered lge_ap2nad_wakeup_interrupt
 10714.602157:   <2> PM: pm_system_irq_wakeup: 89 triggered lge_ap2nad_wakeup_interrupt
 10714.603471:   <2> [LGE] AP2NAD_WAKEUP gpio is asserted to HIGH from i.mx
 10714.603476:   <2> [LGE] register wakeup source
 10714.603491:   <2> [LGE] NAD2AP_WAKEUP GPIO is configured to 0
 10714.606480:   <2> 	[AK7759] ak7759_resume(4381)
 10714.606491:   <2> 	[ak7759] ak7759_resume External PDN[OFF]
 10714.607497:   <2> 	[ak7759] ak7759_resume External PDN[ON]
 10714.608528:   <2> [AK7759] ak7759_write_register (84, 2)
 10714.608532:   <2> [AK7759] ak7759_write_register (85, 1)
 10714.608815:   <2> 	[AK7759] ak7759_set_bias_level(4034)
 10714.608819:   <2> [AK7759] SND_SOC_BIAS_STANDBY
 10714.608865:   <2> [LGE] register wakeup source for pm
 10714.609583:   <2> qcom-ethqos qcom_ethqos_resume:5022 driver load failed
 10714.611547:   <2> OOM killer enabled.
 10714.611553:   <2> Restarting tasks ... done.
 10714.627337:   <2> ipa ipa_pm_notify:498 Entry
 10714.627350:   <2> ipa ipa_pm_notify:510 Exit
 10714.627367:   <2> Resume caused by IRQ 89, lge_ap2nad_wakeup_interrupt
 10714.627385:   <2> PM: suspend exit
 10714.640704:   <2> [0x188820 mhi_sm_pcie_event_manager] Handling EP_PCIE_PM_RST_DEAST_EVENT event, current states: M3 and D3_COLD_STATE
 10714.641191:   <2> ep_pcie_reset_init: After Reset assert pcie_core_reset
 10714.642281:   <2> ep_pcie_reset_init: After Reset de-assert pcie_core_reset
 10714.642303:   <2> ep_pcie_reset_init: After Reset assert pcie_phy_reset
 10714.643389:   <2> ep_pcie_reset_init: After Reset de-assert pcie_phy_reset
 10714.643938:   <2> ep_pcie_core_enable_endpoint: PCIe V1711211: number of PERST retries:0.
 10714.643953:   <2> ep_pcie_phy_init: PCIe V1711211: Unexpected phy version 2103 is caught
 10714.646168:   <2> ep_pcie_core_enable_endpoint: PCIe V1711211: PCIe  PHY is ready
 10714.646277:   <2> ep_pcie_core_init: PCIe V1711211: PCIE20_PARF_INT_ALL_MASK:0x210e
 10714.673998:   <2> ep_pcie_core_enable_endpoint: PCIe V1711211: link initialized for LE PCIe endpoint
 10714.674010:   <2> PCIe - link initialized for LE PCIe endpoint
 10714.678450:   <2> [0x188820 mhi_sm_pcie_event_manager] Handling EP_PCIE_PM_D0_EVENT event, current states: M3 and D0_STATE
 10714.709706:   <2> [0x188820 mhi_dev_notify_sm_event] received: MHI_DEV_EVENT_M0_STATE
 10714.709809:   <2> [0x188820 mhi_sm_dev_event_manager] Handling MHI_DEV_EVENT_M0_STATE event, current states: M3 & D0_STATE
 10714.711168:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10714.712422:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10714.719574:   <2> [LGE] AP2NAD_WAKEUP gpio is asserted to HIGH from i.mx
 10714.719592:   <2> [LGE] register wakeup source
 10714.719608:   <2> [LGE] NAD2AP_WAKEUP GPIO is configured to 0
 10715.376055:   <2> msm-dwc3 a600000.ssusb: DWC3 exited from low power mode
 10715.727615:   <2> android_work: sent uevent USB_STATE=CONNECTED
 10715.731330:   <2> android_work: sent uevent USB_STATE=DISCONNECTED
 10715.875576:   <2> android_work: sent uevent USB_STATE=CONNECTED
 10715.887975:   <2> configfs-gadget gadget: high-speed config #1: c
 10715.890223:   <2> android_work: sent uevent USB_STATE=CONFIGURED
 10769.696807:   <2> android_work: sent uevent USB_STATE=DISCONNECTED
 10769.707269:   <2> msm-dwc3 a600000.ssusb: DWC3 in low power mode
 10770.046686:   <2> [0x188820 mhi_dev_notify_sm_event] received: MHI_DEV_EVENT_M3_STATE
 10770.046740:   <2> [0x188820 mhi_sm_dev_event_manager] Handling MHI_DEV_EVENT_M3_STATE event, current states: M0 & D0_STATE
 10770.052713:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10770.054007:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10770.055275:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10770.056513:   <2> ipa_dma ipa3_dma_enable:420 Already enabled refcnt=1
 10770.058967:   <2> ipa_dma ipa3_dma_disable:491 There is pending work, can't disable.
 10770.058980:   <2> [0x188820 mhi_sm_prepare_suspend] IPA disable fail cnt:0
 10770.071429:   <2> [0x188820 mhi_sm_prepare_suspend] IPA DMA successfully disabled
 10770.084429:   <2> [0x188820 mhi_sm_pcie_event_manager] Handling EP_PCIE_PM_D3_HOT_EVENT event, current states: M3 and D0_STATE
 10770.102801:   <2> [0x188820 mhi_sm_pcie_event_manager] Handling EP_PCIE_PM_D3_COLD_EVENT event, current states: M3 and D3_HOT_STATE
 10770.615429:   <2> PM: suspend entry (deep)
 10770.621215:   <2> Filesystems sync: 0.005 seconds
 10770.621233:   <2> ipa ipa_pm_notify:498 Entry
 10770.621244:   <2> ipa ipa_pm_notify:510 Exit
 10770.624202:   <0> Freezing user space processes ... 
 10770.626056:   <2> f_cdev_poll: Failed due to NULL device or disconnected.
 10770.627553:   <2> (elapsed 0.003 seconds) done.
 10770.627568:   <2> OOM killer disabled.
 10770.627572:   <2> Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
 10770.629003:   <2> printk: Suspending console(s) (use no_console_suspend to debug)
 10770.630732:   <2> qcom-ethqos qcom_ethqos_suspend:4950 driver load failed
 10770.632529:   <2> 	[AK7759] ak7759_set_bias_level(4034)
 10770.632535:   <2> 	[AK7759] SND_SOC_BIAS_OFF
 10770.633378:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10770.633448:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10770.633830:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10770.633901:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10770.633962:   <2> 	[AK7759] ak7759_set_bias_level(4034)
 10770.633965:   <2> 	[AK7759] SND_SOC_BIAS_OFF
 10770.634341:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10770.634409:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10770.634840:   <2> i2c-msm-v2 837000.i2c: NACK: slave not responding, ensure its powered: msgs(n:2 cur:0 tx) bc(rx:1 tx:3) mode:FIFO slv_addr:0x18 MSTR_STS:0x0d1300c8 OPER:0x00000010
 10770.634911:   <2> 	[AK7759] ak7759_read_register error ret = -107
 10770.641488:   <2> gic_show_resume_irq: 145 triggered smp2p
 10770.641529:   <2> PM: pm_system_irq_wakeup: 38 triggered smp2p
 10770.645911:   <2> 	[AK7759] ak7759_resume(4381)
 10770.645923:   <2> 	[ak7759] ak7759_resume External PDN[OFF]
 10770.646928:   <2> 	[ak7759] ak7759_resume External PDN[ON]
 10770.647960:   <2> [AK7759] ak7759_write_register (84, 2)
 10770.647964:   <2> [AK7759] ak7759_write_register (85, 1)
 10770.648209:   <2> 	[AK7759] ak7759_set_bias_level(4034)
 10770.648213:   <2> [AK7759] SND_SOC_BIAS_STANDBY
 10770.648258:   <2> [LGE] register wakeup source for pm
 10770.649035:   <2> qcom-ethqos qcom_ethqos_resume:5022 driver load failed
 10770.651025:   <2> OOM killer enabled.
 10770.651031:   <2> Restarting tasks ... done.
 10770.666969:   <2> ipa ipa_pm_notify:498 Entry
 10770.666985:   <2> ipa ipa_pm_notify:510 Exit
 10770.667002:   <2> Resume caused by IRQ 38, smp2p
 10770.667020:   <2> PM: suspend exit
 10772.288980:   <2> subsys-pil-tz: subsys_err_fatal_intr_handler(): Fatal error on modem!
 10772.289048:   <2> subsys-pil-tz: log_failure_reason(): modem subsystem failure reason: lfw_common_cxn_mgr.c:264:Assertion ((array_ptr->sf_info[cxn_id].proc_orders_done == array_ptr->sf_info[cxn_id].proc_orders_pend) || (array_ptr->sf_info[cxn_id].proc_orders_done == 0)) failed.
 10772.289073:   <2> sdx-asoc-snd soc:sound-auto: sdx_set_modem_state: setting modem state to 0 
 10772.289080:   <2> subsys-restart: subsystem_restart_dev(): Restart sequence requested for modem, restart_level = SYSTEM.
 10772.289170:   <2> Ramdump(ramdump_microdump_modem): No consumers. Aborting..
 10772.289176:   <2> microdump_modem_notifier_nb: do_ramdump() failed
ChatGPT said:

Nice — this is a very useful log. Let me explain it clearly step by step in simple terms 👇

🧩 What’s happening overall

Your log shows a modem crash (subsystem fatal) — specifically triggered after system suspend/resume events.

The critical line is:

modem subsystem failure reason:
lfw_common_cxn_mgr.c:264: Assertion ((array_ptr->sf_info[cxn_id].proc_orders_done == array_ptr->sf_info[cxn_id].proc_orders_pend) || (array_ptr->sf_info[cxn_id].proc_orders_done == 0)) failed.


This is a firmware assertion failure inside the modem (NAD / SDX) code, not a Linux transport or driver issue.

⚙️ Timeline summary

System enters suspend (deep sleep)

PM: suspend entry (deep)


Drivers like qcom-ethqos, AK7759, and I2C are being suspended.

NAD wakeup triggered

[LGE] AP2NAD_WAKEUP gpio is asserted to HIGH from i.mx


The NAD (modem) sends a wakeup signal to AP. Resume happens.

PCIe reinitialization sequence

ep_pcie_reset_init: After Reset assert/de-assert
PCIe - link initialized for LE PCIe endpoint
MHI_DEV_EVENT_M0_STATE


This shows the PCIe link between AP and modem was re-established correctly after resume.

System resumes successfully

Resume caused by IRQ 89, lge_ap2nad_wakeup_interrupt
PM: suspend exit


Everything appears fine until now.

After resume, the modem crashes:

subsys-pil-tz: Fatal error on modem!
modem subsystem failure reason:
lfw_common_cxn_mgr.c:264: Assertion failed


That assertion means the modem’s connection manager detected mismatched “process orders” (internal job scheduling inconsistency).

🧠 What that assertion means

Inside lfw_common_cxn_mgr.c, the assertion:

(proc_orders_done == proc_orders_pend) || (proc_orders_done == 0)


checks whether:

all scheduled operations (pend) are completed (done), or

no operations were started.

The fact it failed means:

Some operations were still pending or in inconsistent state during suspend/resume or PCIe reinit.

In plain words:

The modem firmware woke up, found that some internal transactions (possibly with AP over PCIe or QMI) were left unfinished or mismatched, so it crashed itself intentionally (assertion failure) to recover safely.

💡 Root Cause Possibilities

Firmware-side bug in the modem (common in suspend/resume race conditions).
Likely inside connection manager (cxn_mgr) handling pending transactions.

Improper suspend timing or wakeup event handling from AP → NAD or NAD → AP.
e.g. PCIe/MHI reinitialized too soon or while the modem was still restoring state.

Power sequencing glitch — NAD lost power or reset during transition.

MHI/PCIe resume order mismatch.
The log shows good reinit, but modem side may have re-synced incorrectly.

⚒️ Recommended Actions
Action	Description
Check modem firmware version	If using SDX65/SDX75-based NAD, ensure latest LFW image; Qualcomm often fixes lfw_common_cxn_mgr crashes in newer builds.
Check suspend/resume timing	Verify that AP does not send suspend too early or before MHI goes to M3 (low-power) properly.
Add delay or handshake before PCIe re-enable	A small delay (e.g., 100–200 ms) after wakeup before re-enabling PCIe sometimes avoids race.
Check NAD logs (DLT/NAD trace)	The real root-cause context is often visible in NAD DLT just before assertion.
Compare AP-NAD GPIO toggling	Ensure AP2NAD_WAKEUP and NAD2AP_WAKEUP handshakes are sequenced correctly.
🔍 TL;DR Summary
Event	Description
Suspend entered	Drivers and modem go to sleep
Resume triggered	NAD wakeup interrupt (GPIO 89)
PCIe/MHI link restored	Successfully
A few seconds later	Modem asserts due to internal cxn_mgr state mismatch
Log shows	“Assertion failed” → firmware crash, not AP-side issue

If you can share the corresponding NAD DLT log around the timestamp 10772s, I can point to the exact module or service (LTE, QMI, IPC) that triggered the mismatch.

Would you like me to explain how to trace the NAD DLT log around the crash timestamp to confirm the root cause?

You said:
why assertion failed
ChatGPT said:

Excellent — that’s the core question.
Let’s break down why exactly the assertion failed in your modem log 👇

🧩 The Assertion Line (from crash reason)
lfw_common_cxn_mgr.c:264: 
Assertion (
   (array_ptr->sf_info[cxn_id].proc_orders_done == array_ptr->sf_info[cxn_id].proc_orders_pend) ||
   (array_ptr->sf_info[cxn_id].proc_orders_done == 0)
) failed.


This check happens inside LFW (Low-level Firmware) → Connection Manager (cxn_mgr) — a part of the modem firmware that tracks internal “service flow” (sf_info) tasks.

Let’s decode what it means.

🧠 Meaning of variables
Variable	Meaning
proc_orders_pend	Number of processing orders that are still pending (not completed).
proc_orders_done	Number of orders that have finished execution.
cxn_id	Connection ID (represents a specific channel/session, e.g. QMI, MHI, IP link, etc.)
sf_info	Internal structure holding the state for each connection/service flow.
⚙️ What the assertion expects

The firmware expects either of these to be true:

All pending orders are completed →
proc_orders_done == proc_orders_pend,
✅ normal clean state.

No orders have started yet →
proc_orders_done == 0,
✅ idle state.

If neither is true, it means:

Some operations were in progress or lost in between, leaving inconsistent counts.

That’s why the firmware triggers an assertion failure → to force a crash and reset.

🔍 What can cause this mismatch

Here are realistic, common causes in Qualcomm-based NADs (like SDX55, SDX65, SDX75):

1️⃣ Suspend/resume race condition

When AP enters suspend, modem (NAD) may still be handling some QMI/MHI transactions.
If the AP side powers down PCIe or interrupts too early:

proc_orders_pend was incremented (order started),

but before completion acknowledgment came back,

system slept → that “done” count never got updated.

So after resume:

proc_orders_done != proc_orders_pend


⚠️ Assertion failure.

This is the most common cause.

2️⃣ Power or reset glitch

During suspend, if the modem lost partial context (e.g., RAM retention not working or unexpected reset),
the internal counters become stale. On restore, firmware reads corrupted or out-of-sync sf_info.

3️⃣ Software bug in cxn_mgr itself

Sometimes the connection manager doesn’t properly clear or reset its proc_orders_* fields when:

A connection is torn down,

Or a resume reinitialization runs twice.

This is a firmware defect fixed in later modem releases (for example, QCOM changelogs mention CXN_MGR ASSERT fix during SSR after resume).

4️⃣ Late response from AP

If the NAD requested something via QMI (e.g., NAD_ALIVE_STATUS_REQ) before suspend, and AP responded after resume,
the response lands at the wrong time — cxn_mgr state mismatch.

🧩 So in simple terms:

The assertion failed because the modem firmware found an unfinished transaction that never properly completed during suspend/resume — so the internal state became inconsistent.

To protect system integrity, firmware intentionally crashed itself to recover cleanly rather than continue with corrupted state.

🛠️ How to Confirm

You can verify which connection or service caused it by:

Checking NAD DLT log (look for cxn_id in crash context)

Correlating with QMI service (e.g., QMI_MCS, QMI_NAS, QMI_WDS)

Comparing timestamps before and after suspend (any unacked QMI transactions?)

✅ How to Fix / Avoid
Cause	Mitigation
Suspend while NAD busy	Add delay before AP suspend → wait until all MHI channels in M3 (low power).
Firmware bug	Update NAD firmware image to latest version (especially if based on Qualcomm SDX6x or 7x platform).
Power glitch	Verify PMIC or GPIO power sequence during sleep/resume.
Missed response	Ensure QMI clients complete before suspend.

Would you like me to show how to map the cxn_id that crashed (from NAD DLT log or memory dump) to the exact service (e.g., QMI_NAS, WDS, or MCS)?
That will pinpoint which subsystem (data, modem, QMI control, etc.) caused the assertion.

You said:
Late response from AP why it is suspended
ChatGPT said:

Excellent question 👏 — this is exactly the kind of subtle timing bug that causes these “firmware assertion” issues during suspend/resume sequences.

Let’s go step-by-step in an understandable way 👇

⚙️ The Context: AP ↔ NAD communication

Your system has:

AP (Application Processor) → runs Linux/Android.

NAD (Network Access Device / Modem) → runs its own RTOS (with MHI, QMI services, etc.).

They communicate over PCIe + MHI + QMI layers.

During normal operation:

AP sends QMI requests (e.g., NAD_ALIVE_STATUS_REQ),

NAD processes and sends a QMI response back through MHI → PCIe → AP.

🌙 What happens during suspend

When the system decides to enter suspend (deep sleep or low power):

The AP stops user-space services first.

Then, it suspends PCIe and MHI channels (so no more data transactions).

NAD enters low-power (M3) mode, expecting no more traffic.

But…

if suspend is triggered while a QMI transaction is still in flight,
the NAD may still be processing or waiting for the AP to respond.

⚠️ The “Late Response” scenario

Imagine this sequence:

Step	Event	Who
1	AP sends a QMI request to NAD (e.g., configuration update)	AP
2	NAD receives and starts processing	NAD
3	AP’s power manager triggers suspend right after sending	AP
4	NAD finishes processing and sends a response	NAD
5	But PCIe/MHI link is already suspended — response never reaches AP	—
6	NAD waits for ACK or next request from AP… nothing comes	—
7	When system wakes up, AP resumes late and sends next QMI request	AP
8	NAD checks its internal cxn_mgr: previous transaction incomplete!	NAD
9	Assertion fails (proc_orders_done ≠ proc_orders_pend) → Crash.	💥

That’s your “late response” case —
the NAD sent or expected a message after AP suspended, so internal counters desynchronized.

💡 Why AP gets suspended “too early”

This is usually because:

No suspend blockers were held by the NAD driver.

e.g., /dev/mhi_* or /dev/qrtr* didn’t keep the system awake.

The QMI transaction completion callback didn’t call pm_stay_awake() or equivalent.

Suspend/resume race in kernel driver —
MHI controller enters suspend before DMA/doorbell transactions fully finish.

Power manager aggressively triggers suspend (Android autosleep, automotive sleep timer, etc.) without waiting for NAD.

🧠 In simpler words:

The AP went to sleep too soon while the modem (NAD) was still mid-conversation.
When the AP woke up and responded, it was too late — the modem’s connection manager found its internal counters inconsistent, so it crashed to recover.

✅ How to fix or verify

1️⃣ Add suspend blockers / wake locks
Ensure any active QMI transaction or MHI transfer prevents AP suspend until completion.
→ check driver logs for "pm_runtime_suspend" timing around crash.

2️⃣ Delay suspend entry
Wait until all MHI channels show M3 (suspended) or M0→M3 transition done in logs before suspending AP.

3️⃣ Firmware upgrade
Qualcomm releases sometimes fix NAD side timing tolerances for “late AP resume.”

4️⃣ Cross-check with QRTR logs
You’ll often see:

QMI_MCS_QCSI_PKT MsgType=Request → Response never seen before suspend


followed by a crash after resume → confirms the late-response condition.

Would you like me to show exactly how to identify from logs if your AP actually suspended before the NAD completed its QMI transaction (using timestamps in QRTR + DLT)?
That will confirm whether this late-response case really caused your assertion.




AP SIDE serial logs are comming ttylp2 SEEN dev list and proc command line

C:\Users\gunturu.sai\Documents\platform-tools>adb1 devices
List of devices attached
0123459876      device


C:\Users\gunturu.sai\Documents\platform-tools>adb1 shell
sh-3.2# cd /dev
sh-3.2# ls
autofs                    mmcblk0p5                 tty3
binder                    mmcblk0p6                 tty30
block                     mmcblk0p7                 tty31
bus                       mmcblk0p8                 tty32
button                    mmcblk0p9                 tty33
char                      mmcblk0rpmb               tty34
console                   mqueue                    tty35
cpu_dma_latency           nbd0                      tty36
cuse                      nbd1                      tty37
diag                      nbd10                     tty38
disk                      nbd11                     tty39
dm-0                      nbd12                     tty4
dm-1                      nbd13                     tty40
efuse                     nbd14                     tty41
fd                        nbd15                     tty42
full                      nbd2                      tty43
fuse                      nbd3                      tty44
gpiochip0                 nbd4                      tty45
gpiochip1                 nbd5                      tty46
gpiochip2                 nbd6                      tty47
gpiochip3                 nbd7                      tty48
gpiochip4                 nbd8                      tty49
hugepages                 nbd9                      tty5
hwbinder                  net                       tty50
hwrng                     network_latency           tty51
iio:device0               network_throughput        tty52
initctl                   null                      tty53
ion                       port                      tty54
kmsg                      pps0                      tty55
kvm                       ptmx                      tty56
log                       ptp0                      tty57
loop-control              pts                       tty58
loop0                     ptyp0                     tty59
loop1                     ptyp1                     tty6
loop2                     ptyp2                     tty60
loop3                     ptyp3                     tty61
loop4                     ptyp4                     tty62
loop5                     ptyp5                     tty63
loop6                     ptyp6                     tty7
loop7                     ptyp7                     tty8
mapper                    ptyp8                     tty9
mem                       ptyp9                     ttyLP2
memory_bandwidth          ptypa                     ttyRPMSG50
mhi_0306_00.01.00_pipe_0  ptypb                     ttyRSU30
mmcblk0                   ptypc                     ttyS0
mmcblk0boot0              ptypd                     ttyS1
mmcblk0boot1              ptype                     ttyS2
mmcblk0p1                 ptypf                     ttyS3
mmcblk0p10                random                    ttyp0
mmcblk0p11                rild                      ttyp1
mmcblk0p12                rild2                     ttyp2
mmcblk0p13                rpmsg_ctrl30              ttyp3
mmcblk0p14                rpmsg_ctrl50              ttyp4
mmcblk0p15                rtc0                      ttyp5
mmcblk0p16                shm                       ttyp6
mmcblk0p17                snd                       ttyp7
mmcblk0p18                socket                    ttyp8
mmcblk0p19                stderr                    ttyp9
mmcblk0p2                 stdin                     ttypa
mmcblk0p20                stdout                    ttypb
mmcblk0p21                tee0                      ttypc
mmcblk0p22                teepriv0                  ttypd
mmcblk0p23                tty                       ttype
mmcblk0p24                tty0                      ttypf
mmcblk0p25                tty1                      urandom
mmcblk0p26                tty10                     usb-ffs
mmcblk0p27                tty11                     vcs
mmcblk0p28                tty12                     vcs1
mmcblk0p29                tty13                     vcs2
mmcblk0p3                 tty14                     vcs3
mmcblk0p30                tty15                     vcs4
mmcblk0p31                tty16                     vcs5
mmcblk0p32                tty17                     vcs6
mmcblk0p33                tty18                     vcsa
mmcblk0p34                tty19                     vcsa1
mmcblk0p35                tty2                      vcsa2
mmcblk0p36                tty20                     vcsa3
mmcblk0p37                tty21                     vcsa4
mmcblk0p38                tty22                     vcsa5
mmcblk0p39                tty23                     vcsa6
mmcblk0p4                 tty24                     vndbinder
mmcblk0p40                tty25                     watchdog
mmcblk0p41                tty26                     watchdog0
mmcblk0p42                tty27                     wup
mmcblk0p43                tty28                     zero
mmcblk0p44                tty29
sh-3.2# cat /proc/cmdline
ima_hash=sha256 ima_template=ima-ng ima_appraise_tcb ima_appraise=fix console=ttyLP2,115200 earlycon=lpuart32,0x5a080000,115200 root=/dev/mmcblk0p11 rootwait ro loglevel=3 init=/sbin/init.early lpj=32000 lge.bootmode=normal nad_power=reset


You said:
both are same diag and com
debug uart for console logging

✅ Summary
Component	Description
COM Port (USB DIAG)	PC ↔ Device diagnostic interface
AP ↔ CP DIAG Link	Internal IPC for logging/control
Tools	QXDM, diag_mdlog, diag_revealer
Driver Config	CONFIG_MSM_DIAG, diagchar
DTS Nodes	Ensure GLINK/diag nodes exist


ou’re asking about DIAG vs COM port vs Debug UART, and how they differ or overlap — especially for debugging and logging on an embedded platform (like Qualcomm or STM32MP1-based systems).

Here’s the detailed distinction 👇

⚙️ 1️⃣ COM Port (General Term)

“COM port” = communication port — a Windows term for serial interfaces.

It can represent any serial-over-USB or UART interface.

Example:

COM3 = Debug UART console

COM4 = DIAG port

COM5 = AT command port
These are all different logical interfaces, even though all appear as “COM ports” on Windows.

💡 So:

“COM port” is a generic label, not a function. The purpose depends on what driver or interface it maps to.

🧩 2️⃣ DIAG Port (Diagnostic Port)

The DIAG port is a specific COM interface used for diagnostic communication with the modem (CP) or firmware.

It’s mainly for tools like QXDM / QPST / diag_mdlog to collect logs, NV data, and events from the modem.

✅ Purpose:

Used by Qualcomm’s diagnostic protocol (DIAG protocol).

Not a console — it’s binary data packets for diagnostics.

Typical label on Windows: “Qualcomm HS-USB Diagnostics 90xx (COMx)”

✅ Example mapping on Windows:

Port	Function	Tool
COM3	DIAG	QXDM, QPST
COM4	NMEA (GPS)	GNSS logger
COM5	AT Port	Minicom, PuTTY
COM6	Debug UART	Serial console

This is a plain serial UART interface used for kernel, bootloader, or firmware logs — human-readable text, not binary.

Used for printf logs, dmesg, U-Boot messages, or Linux kernel printk.

✅ Purpose:

Console access (like minicom or screen /dev/ttyUSB0 115200)

View system boot messages

Kernel debugging

Login shell (ttyS0, ttyUSB0)

✅ Physical form:

Usually a 3-pin or 4-pin UART header (TX, RX, GND [, VCC])

Connected to your PC using a USB-to-UART converter (e.g., FTDI, CP2102, CH340)

🔍 4️⃣ Comparing All Three
Feature	COM Port	DIAG Port	Debug UART
Type	Generic serial interface	Diagnostic-specific	Plain text serial console
Data Type	Varies (AT commands, diag, logs)	Binary DIAG packets	ASCII text logs
Used By	OS/driver	Modem / firmware	Developers
Tools	PuTTY, Minicom	QXDM, diag_mdlog	Minicom, screen
Purpose	General communication	Collect modem logs	View kernel/U-Boot logs
Connection	USB or UART	USB or IPC	UART header
Example COM#	COM3	COM4	COM5

COM Port — generic label.

DIAG Port — special COM port used for binary diagnostics between AP–CP or PC–Modem.

Debug UART — text console used for kernel, U-Boot, and user-space logging.
